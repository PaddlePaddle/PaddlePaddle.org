<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="design-doc-supporting-new-device-library">
<span id="design-doc-supporting-new-device-library"></span><h1>Design Doc: Supporting new Device/Library<a class="headerlink" href="#design-doc-supporting-new-device-library" title="永久链接至标题">¶</a></h1>
<div class="section" id="background">
<span id="background"></span><h2>Background<a class="headerlink" href="#background" title="永久链接至标题">¶</a></h2>
<p>Deep learning has a high demand for computing resources. New high-performance devices and computing libraries are appearing very frequently. Deep learning frameworks have to integrate these high-performance devices and computing libraries in a flexible and efficient manner.</p>
<p>On one hand, hardware and computing libraries usually do not have a one-to-one correspondence. For example, Intel CPUs support Eigen and MKL computing libraries while Nvidia GPUs support Eigen and cuDNN computing libraries. We have to implement operator specific kernels for each computing library.</p>
<p>On the other hand, users usually do not want to care about the low-level hardware and computing libraries when writing a neural network configuration. In Fluid, <code class="docutils literal"><span class="pre">Layer</span></code> is exposed in <code class="docutils literal"><span class="pre">Python</span></code>, and <code class="docutils literal"><span class="pre">Operator</span></code> is exposed in <code class="docutils literal"><span class="pre">C++</span></code>. Both <code class="docutils literal"><span class="pre">Layer</span></code> and <code class="docutils literal"><span class="pre">Operator</span></code> are hardware independent.</p>
<p>So, how to support a new Device/Library in Fluid becomes a challenge.</p>
</div>
<div class="section" id="basic-integrate-a-new-device-library">
<span id="basic-integrate-a-new-device-library"></span><h2>Basic: Integrate A New Device/Library<a class="headerlink" href="#basic-integrate-a-new-device-library" title="永久链接至标题">¶</a></h2>
<p>For a general overview of fluid, please refer to the <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/read_source.md">overview doc</a>.</p>
<p>There are mainly three parts that we have to consider while integrating a new device/library:</p>
<ul class="simple">
<li>Place and DeviceContext: indicate the device id and manage hardware resources</li>
<li>Memory and Tensor: malloc/free data on certain device</li>
<li>Math Functor and OpKernel: implement computing unit on certain devices/libraries</li>
</ul>
<div class="section" id="place-and-devicecontext">
<span id="place-and-devicecontext"></span><h3>Place and DeviceContext<a class="headerlink" href="#place-and-devicecontext" title="永久链接至标题">¶</a></h3>
<p>Please note that device and computing library are not one-to-one corresponding. A device can have a lot of computing libraries and a computing library can also support several devices.</p>
<div class="section" id="place">
<span id="place"></span><h4>Place<a class="headerlink" href="#place" title="永久链接至标题">¶</a></h4>
<p>Fluid uses class <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/platform/place.h#L55">Place</a> to represent the device memory where data is located. If we add another device, we have to add the corresponding <code class="docutils literal"><span class="pre">DevicePlace</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="o">|</span>   <span class="n">CPUPlace</span>
<span class="n">Place</span> <span class="o">--|</span>   <span class="n">CUDAPlace</span>
        <span class="o">|</span>   <span class="n">FPGAPlace</span>
</pre></div>
</div>
<p>And <code class="docutils literal"><span class="pre">Place</span></code> is defined as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">boost</span><span class="p">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">CUDAPlace</span><span class="p">,</span> <span class="n">CPUPlace</span><span class="p">,</span> <span class="n">FPGAPlace</span><span class="o">&gt;</span> <span class="n">Place</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="devicecontext">
<span id="devicecontext"></span><h4>DeviceContext<a class="headerlink" href="#devicecontext" title="永久链接至标题">¶</a></h4>
<p>Fluid uses class <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/fluid/paddle/platform/device_context.h#L30">DeviceContext</a> to manage the resources in different libraries, such as CUDA stream in <code class="docutils literal"><span class="pre">CDUADeviceContext</span></code>. There are also inheritance relationships between different kinds of <code class="docutils literal"><span class="pre">DeviceContext</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                <span class="o">/-&gt;</span>  <span class="n">CPUDeviceContext</span>   
<span class="n">DeviceContext</span> <span class="o">----&gt;</span>  <span class="n">CUDADeviceContext</span>  
                \<span class="o">-&gt;</span>  <span class="n">FPGADeviceContext</span>
</pre></div>
</div>
<p>An example of Nvidia GPU is as follows:</p>
<ul class="simple">
<li>DeviceContext</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DeviceContext</span> <span class="p">{</span>
  <span class="n">virtual</span> <span class="n">Place</span> <span class="n">GetPlace</span><span class="p">()</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>  
</pre></div>
</div>
<ul class="simple">
<li>CUDADeviceContext</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CUDADeviceContext</span> <span class="p">:</span> <span class="n">public</span> <span class="n">DeviceContext</span> <span class="p">{</span>
  <span class="n">Place</span> <span class="n">GetPlace</span><span class="p">()</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">place_</span><span class="p">;</span> <span class="p">}</span>
<span class="n">private</span><span class="p">:</span>
  <span class="n">CUDAPlace</span> <span class="n">place_</span><span class="p">;</span>
  <span class="n">cudaStream_t</span> <span class="n">stream_</span><span class="p">;</span>
  <span class="n">cublasHandle_t</span> <span class="n">cublas_handle_</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">GpuDevice</span><span class="o">&gt;</span> <span class="n">eigen_device_</span><span class="p">;</span>  <span class="o">//</span> <span class="n">binds</span> <span class="k">with</span> <span class="n">stream_</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="memory-and-tensor">
<span id="memory-and-tensor"></span><h3>Memory and Tensor<a class="headerlink" href="#memory-and-tensor" title="永久链接至标题">¶</a></h3>
<div class="section" id="memory-module">
<span id="memory-module"></span><h4>memory module<a class="headerlink" href="#memory-module" title="永久链接至标题">¶</a></h4>
<p>Fluid provides the following <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/memory/memory.h#L36">memory interfaces</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Place</span><span class="o">&gt;</span>
<span class="n">void</span><span class="o">*</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">Place</span> <span class="n">place</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Place</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">Free</span><span class="p">(</span><span class="n">Place</span> <span class="n">place</span><span class="p">,</span> <span class="n">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Place</span><span class="o">&gt;</span>
<span class="n">size_t</span> <span class="n">Used</span><span class="p">(</span><span class="n">Place</span> <span class="n">place</span><span class="p">);</span>
</pre></div>
</div>
<p>To implement these interfaces, we have to implement MemoryAllocator for different Devices.</p>
</div>
<div class="section" id="tensor">
<span id="tensor"></span><h4>Tensor<a class="headerlink" href="#tensor" title="永久链接至标题">¶</a></h4>
<p><a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/framework/tensor.h#L36">Tensor</a> holds data with some shape in a specific Place.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tensor</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="cm">/*! Return a pointer to mutable memory block. */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">();</span>

  <span class="cm">/**</span>
<span class="cm">   * @brief   Return a pointer to mutable memory block.</span>
<span class="cm">   * @note    If not exist, then allocation.</span>
<span class="cm">   */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">mutable_data</span><span class="p">(</span><span class="n">platform</span><span class="o">::</span><span class="n">Place</span> <span class="n">place</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * @brief     Return a pointer to mutable memory block.</span>
<span class="cm">   *</span>
<span class="cm">   * @param[in] dims    The dimensions of the memory block.</span>
<span class="cm">   * @param[in] place   The place of the memory block.</span>
<span class="cm">   *</span>
<span class="cm">   * @note      If not exist, then allocation.</span>
<span class="cm">   */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">mutable_data</span><span class="p">(</span><span class="n">DDim</span> <span class="n">dims</span><span class="p">,</span> <span class="n">platform</span><span class="o">::</span><span class="n">Place</span> <span class="n">place</span><span class="p">);</span>

  <span class="cm">/*! Resize the dimensions of the memory block. */</span>
  <span class="kr">inline</span> <span class="n">Tensor</span><span class="o">&amp;</span> <span class="n">Resize</span><span class="p">(</span><span class="k">const</span> <span class="n">DDim</span><span class="o">&amp;</span> <span class="n">dims</span><span class="p">);</span>

  <span class="cm">/*! Return the dimensions of the memory block. */</span>
  <span class="kr">inline</span> <span class="k">const</span> <span class="n">DDim</span><span class="o">&amp;</span> <span class="n">dims</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="cm">/*! holds the memory block if allocated. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Placeholder</span><span class="o">&gt;</span> <span class="n">holder_</span><span class="p">;</span>

  <span class="cm">/*! points to dimensions of memory block. */</span>
  <span class="n">DDim</span> <span class="n">dim_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Placeholder</span></code> is used to delay memory allocation; that is, we can first define a tensor, using <code class="docutils literal"><span class="pre">Resize</span></code> to configurate its shape, and then call <code class="docutils literal"><span class="pre">mutuable_data</span></code> to allocate the actual memory.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">paddle</span><span class="o">::</span><span class="n">framework</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">t</span><span class="p">;</span>
<span class="n">paddle</span><span class="o">::</span><span class="n">platform</span><span class="o">::</span><span class="n">CPUPlace</span> <span class="n">place</span><span class="p">;</span>
<span class="c1">// set size first</span>
<span class="n">t</span><span class="p">.</span><span class="n">Resize</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
<span class="c1">// allocate memory on CPU later</span>
<span class="n">t</span><span class="p">.</span><span class="n">mutable_data</span><span class="p">(</span><span class="n">place</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="math-functor-and-opkernel">
<span id="math-functor-and-opkernel"></span><h3>Math Functor and OpKernel<a class="headerlink" href="#math-functor-and-opkernel" title="永久链接至标题">¶</a></h3>
<p>Fluid implements computing units based on different DeviceContexts. Some computing units are shared between operators. This common part will be put in operators/math directory as basic Functors.</p>
<p>Let’s take <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/operators/math/maxouting.h#L27">MaxOutFunctor</a> as an example:</p>
<p>The interface is defined in the header file.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">DeviceContext</span><span class="p">,</span> <span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MaxOutFunctor</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">const</span> <span class="n">DeviceContext</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">,</span> <span class="n">const</span> <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">&amp;</span> <span class="nb">input</span><span class="p">,</span>
                  <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">*</span> <span class="n">output</span><span class="p">,</span> <span class="nb">int</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>CPU implementation is in .cc file</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MaxOutFunctor</span><span class="o">&lt;</span><span class="n">platform</span><span class="p">::</span><span class="n">CPUDeviceContext</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">const</span> <span class="n">platform</span><span class="p">::</span><span class="n">CPUDeviceContext</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">&amp;</span> <span class="nb">input</span><span class="p">,</span> <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">*</span> <span class="n">output</span><span class="p">,</span>
                  <span class="nb">int</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
                  <span class="o">...</span>
                  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>CUDA implementation is in .cu file</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MaxOutFunctor</span><span class="o">&lt;</span><span class="n">platform</span><span class="p">::</span><span class="n">CUDADeviceContext</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">const</span> <span class="n">platform</span><span class="p">::</span><span class="n">CUDADeviceContext</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">&amp;</span> <span class="nb">input</span><span class="p">,</span> <span class="n">framework</span><span class="p">::</span><span class="n">Tensor</span><span class="o">*</span> <span class="n">output</span><span class="p">,</span>
                  <span class="nb">int</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
                  <span class="o">...</span>
                  <span class="p">}</span>
<span class="p">};</span>                  
</pre></div>
</div>
<p>We first obtain the computing handle from a concrete DeviceContext and then compute on tensors.</p>
<p>The implementation of <code class="docutils literal"><span class="pre">OpKernel</span></code> is similar to math functors, the extra thing we need to do is to register the OpKernel in a global map.</p>
<p>Fluid provides different register interfaces in op_registry.h</p>
<p>Let’s take <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/operators/crop_op.cc#L134">Crop</a> operator as an example:</p>
<p>In .cc file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">REGISTER_OP_CPU_KERNEL</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="n">ops</span><span class="p">::</span><span class="n">CropKernel</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">REGISTER_OP_CPU_KERNEL</span><span class="p">(</span>
    <span class="n">crop_grad</span><span class="p">,</span> <span class="n">ops</span><span class="p">::</span><span class="n">CropGradKernel</span><span class="o">&lt;</span><span class="n">paddle</span><span class="p">::</span><span class="n">platform</span><span class="p">::</span><span class="n">CPUDeviceContext</span><span class="p">,</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>In .cu file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">REGISTER_OP_CUDA_KERNEL</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="n">ops</span><span class="p">::</span><span class="n">CropKernel</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">REGISTER_OP_CUDA_KERNEL</span><span class="p">(</span>
    <span class="n">crop_grad</span><span class="p">,</span> <span class="n">ops</span><span class="p">::</span><span class="n">CropGradKernel</span><span class="o">&lt;</span><span class="n">paddle</span><span class="p">::</span><span class="n">platform</span><span class="p">::</span><span class="n">CUDADeviceContext</span><span class="p">,</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="advanced-topics-how-to-switch-between-different-device-library">
<span id="advanced-topics-how-to-switch-between-different-device-library"></span><h2>Advanced topics: How to switch between different Device/Library<a class="headerlink" href="#advanced-topics-how-to-switch-between-different-device-library" title="永久链接至标题">¶</a></h2>
<p>Generally, we will implement OpKernel for all Device/Library of an Operator. We can easily train a Convolutional Neural Network in GPU. However, some OpKernel is not suitable on a specific Device. For example, crf operator can only run on CPU, whereas most other operators can run on GPU. To achieve high performance in such circumstance, we have to switch between different Device/Library.</p>
<p>For more details, please refer to following docs:</p>
<ul class="simple">
<li>operator kernel type <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/multi_devices/operator_kernel_type.md">doc</a></li>
<li>switch kernel <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/execution/switch.md">doc</a></li>
</ul>
</div>
</div>
</div>
<div class="articleComments">
</div>
</div>