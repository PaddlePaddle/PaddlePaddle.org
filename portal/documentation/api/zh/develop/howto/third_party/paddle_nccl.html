<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="design-doc-nccl-support-in-paddle-fluid">
<span id="design-doc-nccl-support-in-paddle-fluid"></span><h1>Design Doc: NCCL support in Paddle Fluid<a class="headerlink" href="#design-doc-nccl-support-in-paddle-fluid" title="永久链接至标题">¶</a></h1>
<div class="section" id="abstract">
<span id="abstract"></span><h2>Abstract<a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>This Design Doc refers to the NCCL feature in  paddle.  We propose an approach to support NCCL library both on a single machine and multiple machines. We wrapper the NCCL primitives <code class="docutils literal"><span class="pre">Broadcast</span></code>, <code class="docutils literal"><span class="pre">Allreduce</span></code>, <code class="docutils literal"><span class="pre">Reduce</span></code> as operators to utilize Multi-GPU powers in one script.</p>
</div>
<div class="section" id="motivation">
<span id="motivation"></span><h2>Motivation<a class="headerlink" href="#motivation" title="永久链接至标题">¶</a></h2>
<p><a class="reference external" href="https://developer.nvidia.com/nccl">NCCL</a> is a NVIDIA library support Multi-GPU communicating and optimized for NVIDIA GPUs, it provides routines such as all-gather, all-reduce, broadcast, reduce, reduce-scatter, that can achieve high bandwidth over PCIe and NVLink high-speed interconnect. With NCCL library, we can easily accelerate the training in parallel.</p>
<ul class="simple">
<li>Pros</li>
</ul>
<ol class="simple">
<li>easily plug-in with <a class="reference external" href="https://developer.nvidia.com/nccl">NCCL2</a> library.</li>
<li>high performance in NVIDIA GPUs.</li>
<li>MPI like primitives, which have low learning cost for users.</li>
</ol>
<ul class="simple">
<li>Cons</li>
</ul>
<ol class="simple">
<li>Only design for NVIDIA GPUs, not a general multi-device solution.</li>
<li>Although NCCL1 is opensourced under BSD license, but NCCL2 is not opensourced anymore.</li>
</ol>
<p>At the beginning of training, the framework needs to distribute the same parameters to every GPU, and merge the gradients at any time user interests.</p>
<p>As a result, during training, we need the operations of peer to peer copy between different GPUs, aggregating gradients/parameters from GPUs, and broadcasting parameters to GPUs. Every GPU only need to run the operator with correct place information.</p>
<p>Besides, it needs interfaces to synchronize model update with each different GPU Cards.</p>
</div>
<div class="section" id="implementation">
<span id="implementation"></span><h2>Implementation<a class="headerlink" href="#implementation" title="永久链接至标题">¶</a></h2>
<p>As mentioned above, we wrap the NCCL routines as several kinds of operators. Need to note that NCCL need to create Communicator between gpu at the beginning, so there is a NCCLInit operator created.</p>
<div class="section" id="transpiler">
<span id="transpiler"></span><h3>Transpiler<a class="headerlink" href="#transpiler" title="永久链接至标题">¶</a></h3>
<p>To be compatible with <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/design/ops/dist_train.md">parameter server design doc</a>, the transpiler compiles the user defined operation graph into sub-graphs to be executed on different devices.</p>
<ol>
<li><p class="first">The user-defined model will be a single device program</p>
</li>
<li><p class="first">Broadcast/Reduce operators between GPUs will be inserted into the program, even for the multi-node, may insert the <code class="docutils literal"><span class="pre">Send</span></code>, <code class="docutils literal"><span class="pre">Recv</span></code> operator.</p>
<p><em>Broadcast, AllReduce in a single machine. And Broadcast, AllReduce, <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/design/ops/dist_train.md#graph-converter">Send, Recv</a> in multiple machines</em></p>
<p><img src="images/multigpu_before_convert.png" width="300"/></p>
</li>
</ol>
<p>After compiling, the graph as shows</p>
<p><img src="images/multigpu_allreduce.png" width="1000"/></p>
<p>Operators are added to the sub-graphs. Every GPU assigned a role of <code class="docutils literal"><span class="pre">rank0</span></code>, <code class="docutils literal"><span class="pre">rank1</span></code> etc.</p>
<ul class="simple">
<li><strong>Broadcast</strong>. Broadcast operator distribute initialized parameter to all the GPUs from the GPU who owns it. e.g. from<code class="docutils literal"><span class="pre">rank0</span></code> GPU.</li>
<li><strong>AllReduce</strong>. AllReduce operator synchronizes parameters/gradients between GPUs. AllReduce implemented in the Ring-Based  communicating method, avoid of the bottle neck in a single GPU.</li>
</ul>
<p>Need to notice that AllReduce operator force GPUs synchronized at that point. The whole training process in asynchronous or synchronous mode depends on the AllReduce point in the graph.</p>
<p>As it shown in the picture, when each GPU compute the gradient of <code class="docutils literal"><span class="pre">W</span></code>, followed with a <code class="docutils literal"><span class="pre">AllReduce</span></code> operator, accumulate the <code class="docutils literal"><span class="pre">dW</span></code> to full batch of data, then run the optimize process individually and apply the gradient to its <code class="docutils literal"><span class="pre">W</span></code>.</p>
<ul class="simple">
<li><strong>AllReduce</strong>
Need to note that our AllReduce operator is a ring-base AllReduce implementation. If we use the NCCL2 AllReduce primitive, every GPU optimized full batch of data, wasted (n-1) GPU compute resources. In addition, NCCL2 built-in AllReduce will only utilize the communicating resource during synchronization, then update the gradient will be a subsequent phase. In fact, we can amortize the update gradient time cost into the communicating phase. The process is</li>
</ul>
<ol class="simple">
<li>Every parameter has its root card. That card will responsible for aggregating the gradients from GPUs.</li>
<li>The whole model’s parameter will be hashed to different root card, ensure the load balance between GPUs.</li>
<li>Logically neighberhood card will start send parameter to the next one. After one round, the parameter main card will aggregate the full gradients.</li>
<li>Then the root card will optimize the parameter.</li>
<li>This parameter card will send its optimized result to its neighberhood, then the neighberhood will send parameter to its next one.</li>
<li>Finish the sychronization round.</li>
</ol>
<p>The total time cost will be 2 * (n-1) * per-parameter-send-time, we reach the goal of amortize the upgrade time into communicating phase.</p>
</div>
</div>
</div>
</div>
<div class="articleComments">
</div>
</div>