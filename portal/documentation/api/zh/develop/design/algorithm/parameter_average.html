<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="averaging-parameter-in-paddlepaddle">
<span id="averaging-parameter-in-paddlepaddle"></span><h1>Averaging Parameter in PaddlePaddle<a class="headerlink" href="#averaging-parameter-in-paddlepaddle" title="永久链接至标题">¶</a></h1>
<div class="section" id="why-averaging">
<span id="why-averaging"></span><h2>Why Averaging<a class="headerlink" href="#why-averaging" title="永久链接至标题">¶</a></h2>
<p>In a large scale machine learning setup where the size of the training data is huge, it could take us a large number of iterations over the training data before we can achieve the optimal values of parameters of our model. Looking at the problem setup, it is desirable to obtain the optimal values of parameters by going through the data in as few passes as possible.</p>
<p>Polyak and Juditsky (1992) showed that the test performance of simple average of parameters obtained by Stochastic Gradient Descent (SGD) is as good as that of parameter values that are obtained by training the model over and over again, over the training dataset.</p>
<p>Hence, to accelerate the speed of Stochastic Gradient Descent, Averaged Stochastic Gradient Descent (ASGD) was proposed in Polyak and Juditsky (1992). For ASGD, the running average of parameters obtained by SGD, is used as the estimator for <img src="https://raw.githubusercontent.com/PaddlePaddle/Paddle/develop/doc/fluid/images/theta_star.gif"/><br/> . The averaging is done as follows:</p>
<p align="center">
<img src="https://raw.githubusercontent.com/PaddlePaddle/Paddle/develop/doc/fluid/images/asgd.gif"/><br/>
</p><p>We propose averaging for any optimizer similar to how ASGD performs it, as mentioned above.</p>
<div class="section" id="how-to-perform-parameter-averaging-in-paddlepaddle">
<span id="how-to-perform-parameter-averaging-in-paddlepaddle"></span><h3>How to perform Parameter Averaging in PaddlePaddle<a class="headerlink" href="#how-to-perform-parameter-averaging-in-paddlepaddle" title="永久链接至标题">¶</a></h3>
<p>Parameter Averaging in PaddlePaddle works in the following way during training :</p>
<ol class="simple">
<li>It will take in an instance of an optimizer as an input, e.g. RMSPropOptimizer</li>
<li>The optimizer itself is responsible for updating the parameters.</li>
<li>The ParameterAverageOptimizer maintains a separate copy of the parameters for itself:<ol>
<li>In theory, the values of this copy are the average of the values of the parameters in the most recent N batches.</li>
<li>However, saving all N instances of the parameters in memory is not feasible.</li>
<li>Therefore, an approximation algorithm is used.</li>
</ol>
</li>
</ol>
<p>Hence, overall we have have two copies of the parameters: one for the optimizer itself, and one for the ParameterAverageOptimizer. The former should be used in back propagation, while the latter should be used during testing and should be saved.</p>
<p>During the testing/saving the model phase, we perform the following steps:</p>
<ol class="simple">
<li>Perform the delayed operations.</li>
<li>Save current values of the parameters to a temporary variable.</li>
<li>Replace the values of the parameters with the averaged values.</li>
<li>Perform testing and/or save the parameters.</li>
<li>Restore the values of the parameters once done.</li>
</ol>
</div>
<div class="section" id="how-to-implement-averaging-of-parameter-in-paddlepaddle">
<span id="how-to-implement-averaging-of-parameter-in-paddlepaddle"></span><h3>How to implement Averaging of Parameter in PaddlePaddle<a class="headerlink" href="#how-to-implement-averaging-of-parameter-in-paddlepaddle" title="永久链接至标题">¶</a></h3>
<p>We can add the ParameterAverageOptimizer op to the graph through Python API. Using this approach, we manually add this op to the graph and direct the output of the optimizer op to this op during training.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">**</span><span class="n">Advantages</span><span class="o">**</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Allows</span> <span class="k">for</span> <span class="n">greater</span> <span class="n">flexibility</span> <span class="n">to</span> <span class="n">the</span> <span class="n">users</span> <span class="n">of</span> <span class="n">PaddlePaddle</span><span class="o">.</span> <span class="n">Using</span> <span class="n">this</span> <span class="n">approach</span><span class="p">,</span> <span class="n">the</span> <span class="n">users</span> <span class="n">can</span> <span class="n">plug</span> <span class="n">different</span> <span class="n">optimizers</span> <span class="n">into</span> <span class="n">ParameterAverageOptimizer</span> <span class="n">by</span> <span class="n">passing</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">optimizer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">op</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Makes</span> <span class="n">it</span> <span class="n">easy</span> <span class="k">for</span> <span class="n">the</span> <span class="n">users</span> <span class="n">to</span> <span class="n">customize</span> <span class="ow">and</span> <span class="n">extend</span> <span class="n">the</span> <span class="n">framework</span><span class="o">.</span>

<span class="o">**</span><span class="n">Disadvantages</span><span class="o">**</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Implementation</span> <span class="n">requires</span> <span class="n">re</span><span class="o">-</span><span class="n">writing</span> <span class="n">the</span> <span class="n">averaging</span> <span class="n">methodology</span> <span class="ow">in</span> <span class="n">Python</span><span class="o">.</span>  
</pre></div>
</div>
</div>
<div class="section" id="low-level-implementation">
<span id="low-level-implementation"></span><h3>Low-Level implementation<a class="headerlink" href="#low-level-implementation" title="永久链接至标题">¶</a></h3>
<p>In the new design, we propose to create a new operation for averaging parameter updates (ParameterAverageOptimizer). For now, we can add an op that takes in the following as input:</p>
<ul class="simple">
<li>the optimizer</li>
<li>the window_size to keep the updates</li>
</ul>
<p>The ParameterAverageOptimizer op can be like any other operator with its own CPU/GPU implementation either using Eigen or separate CPU and GPU kernels. As the initial implementation, we can implement the kernel using Eigen following the abstraction pattern implemented for <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/operators/rmsprop_op.h">Operators</a>. We also want to support the case when the Trainer/Optimizer runs on the GPU while ParameterAverageOptimizer runs on a CPU.</p>
<p>The idea of building an op for averaging is in sync with the refactored PaddlePaddle philosophy of using operators to represent any computation unit. The way the op will be added to the computation graph will be decided by the <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/modules/python_api.md#layer-function">layer functions</a> in Python API.</p>
</div>
<div class="section" id="python-api-implementation-for-parameteraverageoptimizer">
<span id="python-api-implementation-for-parameteraverageoptimizer"></span><h3>Python API implementation for ParameterAverageOptimizer<a class="headerlink" href="#python-api-implementation-for-parameteraverageoptimizer" title="永久链接至标题">¶</a></h3>
<p>Based on Polyak and Juditsky (1992), we can generalize the averaging of updates to any optimizer. The input to the op would be the following:</p>
<ul class="simple">
<li>Any optimizer (RMSProp , AdaGrad etc.)</li>
<li>A window size. The op keeps accumulating updated parameter values over a window of N batches and takes an average. Move the averaged value to a buffer when window is full to avoid loss of precision.</li>
</ul>
<p>Using the ParameterAverageOptimizer op, any user can add the operation to their computation graphs. However, this will require a lot of lines of code and we should design Python APIs that support averaging. As per the PaddlePaddle <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/modules/python_api.md">Python API design</a>, the layer functions are responsible for creating operators, operator parameters and variables. Since ParameterAverageOptimizer will be an operator, it makes sense to create it in the layer functions.
We will have a wrapper written in Python that will support the functionality and implement the actual core computation in C++ core as we have done for other <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/operators/rmsprop_op.cc">Optimizers</a></p>
<div class="section" id="creation-of-the-parameteraverageoptimizer-operator">
<span id="creation-of-the-parameteraverageoptimizer-operator"></span><h4>Creation of the ParameterAverageOptimizer operator<a class="headerlink" href="#creation-of-the-parameteraverageoptimizer-operator" title="永久链接至标题">¶</a></h4>
<p>There are two ways for creating the ParameterAverageOptimizer op:</p>
<ol class="simple">
<li>We create the op immediately while building the computation graph.</li>
<li>We add the op in a lazy manner, just before the backward pass, similar to the way the optimization ops are added.</li>
</ol>
<p>The proposal is to add the op immediately while building the computation graph.</p>
</div>
<div class="section" id="high-level-api">
<span id="high-level-api"></span><h4>High-level API<a class="headerlink" href="#high-level-api" title="永久链接至标题">¶</a></h4>
<p>In PaddlePaddle Python API, users will primarily rely on <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/modules/python_api.md#layer-function">layer functions</a> to create neural network layers. Hence, we also need to provide parameter average functionality in layer functions.</p>
</div>
</div>
</div>
</div>
</div>
<div class="articleComments">
</div>
</div>