<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="background">
<span id="background"></span><h1>Background<a class="headerlink" href="#background" title="永久链接至标题">¶</a></h1>
<p><a class="reference external" href="https://github.com/onnx/onnx">ONNX (Open Neural Network Exchange)</a> bridges different deep learning frameworks by providing an open source graph format for models. The models trained in other frameworks can be converted into the ONNX format to execute inference by utilizing the built-in operators in ONNX - this is called a <strong>frontend</strong>. With the inverse conversion (called a <strong>backend</strong>), different frameworks can share any models supported by ONNX in principle. Now most mainstream frameworks have joined the ONNX community, e.g. Caffe2, PyTorch, and MXNet etc. And there is a momentum driving more and more vendors to begin supporting ONNX or even choose ONNX as the only machine learning runtime in their devices.</p>
<p>Therefore, it is necessary to enable the conversion between PaddlePaddle and ONNX. This design doc is aimed at implementing a convertor, mainly for converting between <strong>Fluid</strong> models and ONNX (it is very likely that we may support older v2 models in the future). A complete convertor should be bidirectional - with a frontend AND a backend, but considering the importance, the we will start with the frontend i.e. Fluid models to ONNX models.</p>
</div>
<div class="section" id="how-it-works">
<span id="how-it-works"></span><h1>How it works<a class="headerlink" href="#how-it-works" title="永久链接至标题">¶</a></h1>
<p>ONNX has a <a class="reference external" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md">working list of operators</a> which is versioned.</p>
<p>When prioritizing implementation of a frontend over a backend, choice of coverage of Fluid -&gt; ONNX operators comes down to choices of models to be supported (see section <code class="docutils literal"><span class="pre">Supported</span> <span class="pre">models</span></code>). Eventually, this will allow us to reach a really-wide coverage of all operators.</p>
<p>Here are a few major considerations when it comes to converting models:</p>
<ul class="simple">
<li><strong>Op-level conversion</strong>: How to map the inputs, attributes, and outputs of each Paddle operator to those of the ONNX operator. In several cases, these require transformations. For each direction (frontend vs. backend), a different conversion mapping is needed.</li>
<li><strong>Parameters (weights) initialization</strong>: Setting initial parameters on different nodes.</li>
<li><strong>Tensor data type mapping</strong> (Note: Some ONNX data types are not supported in Fluid)</li>
<li><strong>Network representation adaption</strong>: Fluid <code class="docutils literal"><span class="pre">ProgramDesc</span></code> include nested blocks. Since ONNX is free of nesting, the <code class="docutils literal"><span class="pre">ProgramDesc</span></code> ops need to be traversed to only include ops from the global scope in the root block. The variables used as inputs and outputs should also be in this scope.</li>
<li><strong>Model validation</strong>: There are two kinds of validations that are necessary:<ol>
<li>We need to ensure that the inference outputs of the ops in run inside a model are the same as those when running the ONNX converted ops through an alternative ONNX backend.</li>
<li>Checking to see if the generated nodes on the graph are validated by the internal ONNX checkers.</li>
</ol>
</li>
<li><strong>Versioning</strong>: ONNX versions its op listing over versions. In fact, it has versioning on 3 different levels: ops, graphs, and ONNX models. This requires that we are conscious about versioning the convertor and updating tests and op convertor logic for each release. It also implies that we release pre-trained ONNX models upon each version release.</li>
</ul>
<p>One thing that makes this conversion more feasible in Fluid’s case is the use of a static IR - the <code class="docutils literal"><span class="pre">ProgramDesc</span></code> - as opposed to a dynamic graph, as created in the cases of frameworks like PyTorch.</p>
</div>
<div class="section" id="project-structure">
<span id="project-structure"></span><h1>Project structure<a class="headerlink" href="#project-structure" title="永久链接至标题">¶</a></h1>
<p align="center">
<img src="./images/project_structure.png"/>
</p><p>The project contains four important parts:</p>
<ul class="simple">
<li><strong>fluid</strong>: The directory that contains wrappers for fluid related APIs. Fluid has provided some low-level APIs to parse or generate the inference model. However, directly using these low-level APIs makes the code tediously long. This module wraps low-level APIs to provide simplified interfaces.</li>
<li><strong>onnx</strong>: This is a Python package provided by ONNX containing helpers for creating nodes, graphs, and eventually binary protobuf models with initializer parameters.</li>
<li><strong>onnx_fluid</strong>: Contains two-way mapping (Fluid -&gt; ONNX ops and ONNX -&gt; Fluid ops). Called from <code class="docutils literal"><span class="pre">convert.py</span></code>, the program uses this mapping along with modifier functions to construct ONNX nodes with the help of ONNX’s <code class="docutils literal"><span class="pre">make_node</span></code> helper. It also contains mapping between datatypes and tensor deprecation / amplification logic.</li>
<li><strong>convert.py</strong>: The interface exposed to users. This will traverse the global program blocks/variables and construct the write-able model.</li>
</ul>
</div>
<div class="section" id="usage">
<span id="usage"></span><h1>Usage<a class="headerlink" href="#usage" title="永久链接至标题">¶</a></h1>
<p>The converter should be designed to very easy-to-use. Bidirectional conversion between a Fluid inference model and an ONNX binary model will be supported. Model validation will also provided to verify the correctness of converted model.</p>
<ul>
<li><p class="first">Convert Fluid inference model to ONNX binary model</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">convert</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">fluid_model</span> <span class="o">&lt;</span><span class="n">fluid</span> <span class="n">inference</span> <span class="n">model</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">onnx_model</span> <span class="o">&lt;</span><span class="n">ONNX</span> <span class="n">model</span><span class="o">&gt;</span> <span class="n">validate</span> <span class="kc">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Validate the converted model</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">validate</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">fluid_model</span> <span class="o">&lt;</span><span class="n">fluid</span> <span class="n">inference</span> <span class="n">model</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">onnx_model</span> <span class="o">&lt;</span><span class="n">ONNX</span> <span class="n">model</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
</ul>
<p>The conversion and model validation will be completed consecutively, finally output a readable model structure description. And for the converse conversion, users only need to exchange the input and output.</p>
</div>
<div class="section" id="challenges-and-mitigation">
<span id="challenges-and-mitigation"></span><h1>Challenges and mitigation<a class="headerlink" href="#challenges-and-mitigation" title="永久链接至标题">¶</a></h1>
<div class="section" id="cycles">
<span id="cycles"></span><h2>Cycles<a class="headerlink" href="#cycles" title="永久链接至标题">¶</a></h2>
<p>Cycles are unsupported in ONNX. In Paddle, the <code class="docutils literal"><span class="pre">while</span></code> op is the most prominent example of a cycle.</p>
<p><em>Resolution</em>: We won’t support models with <code class="docutils literal"><span class="pre">while</span></code>s which can’t be substituted until ONNX adds support for such ops.</p>
</div>
<div class="section" id="sequences">
<span id="sequences"></span><h2>Sequences<a class="headerlink" href="#sequences" title="永久链接至标题">¶</a></h2>
<p>Sequence processing operators like <code class="docutils literal"><span class="pre">sequence_expand</span></code>, <code class="docutils literal"><span class="pre">sequence_reshape</span></code>, <code class="docutils literal"><span class="pre">sequence_concat</span></code>, and <code class="docutils literal"><span class="pre">sequence_pool</span></code> are not supported by ONNX as well, because they do not support non-padded datatypes like LoDTensors.</p>
<p><em>Resolution</em>: Since the runtimes using our ONNX exported graphs won’t be using LoDTensors in the first place, such sequence operators should be mapped to ONNX ops that will do the necessary transposing ops with the knowledge of the padding and shape of the Tensors.</p>
</div>
<div class="section" id="ops-that-can-t-easily-be-mapped">
<span id="ops-that-can-t-easily-be-mapped"></span><h2>Ops that can’t easily be mapped<a class="headerlink" href="#ops-that-can-t-easily-be-mapped" title="永久链接至标题">¶</a></h2>
<p>There are ops that just aren’t possible to map today:</p>
<p><strong>Control flow operators</strong></p>
<p>Paddle supports control flow ops like <code class="docutils literal"><span class="pre">If/Else</span></code> and <code class="docutils literal"><span class="pre">Switch</span></code> (if we ignore the CSP operations like <code class="docutils literal"><span class="pre">select</span></code> for now). ONNX has <code class="docutils literal"><span class="pre">If</span></code> support in the experimental phase.</p>
<p><em>Resolution</em>: Map Paddle’s <code class="docutils literal"><span class="pre">If/Else</span></code> to ONNX’s <code class="docutils literal"><span class="pre">If</span></code>, but ignore other control flow operators until ONNX brings support for them.</p>
<p><strong>Non-existent in Fluid</strong></p>
<p>There are several ONNX operators that are not available in Fluid today, e.g. <code class="docutils literal"><span class="pre">InstanceNormalization</span></code>, <code class="docutils literal"><span class="pre">RandomUniform</span></code>, <code class="docutils literal"><span class="pre">Unsqueeze</span></code>, etc.</p>
<p><em>Resolution</em>: For the initial phase, we can choose to not support ops that our models don’t care for and are subsequently not available in Fluid. However, for ops that we think might be necessary for Fluid users also, we must implement them on our side and support the ONNX conversion to them. This list is TBD.</p>
<p><strong>Concurrency</strong></p>
<p>ONNX does not have any considerations for concurrency right now.</p>
<p><em>Resolution</em>: There are two ways to approach this:</p>
<p>a. We choose to not support concurrent models.
b. We only support <code class="docutils literal"><span class="pre">go_op</span></code>s (basically threads) shallowly. This could mean that we enqueue <code class="docutils literal"><span class="pre">go_op</span></code> ops prior to gradient calculations OR even prior to the entire graph, and that’s it - since <code class="docutils literal"><span class="pre">go_op</span></code>s do not have support for backprop anyways. One of the core target use cases of <code class="docutils literal"><span class="pre">go_op</span></code>: batch reading - can be handled through this approach.</p>
<p><strong>Overloaded in Fluid</strong></p>
<p>There are ops in ONNX whose job can’t be accomplished by a single corresponding Paddle operator (e.g. ), but a collection of operators.</p>
<p><em>Resolution</em>: Chain multiple Paddle operators.</p>
</div>
<div class="section" id="lack-of-lodtensors">
<span id="lack-of-lodtensors"></span><h2>Lack of LoDTensors<a class="headerlink" href="#lack-of-lodtensors" title="永久链接至标题">¶</a></h2>
<p>As stated above, ONNX only supports simple Tensor values.</p>
<p><em>Resolution</em>: Deprecate to plain old numpy-able tensors.</p>
</div>
<div class="section" id="reconstruction-from-deprecated-onnx-ops">
<span id="reconstruction-from-deprecated-onnx-ops"></span><h2>Reconstruction from deprecated ONNX ops<a class="headerlink" href="#reconstruction-from-deprecated-onnx-ops" title="永久链接至标题">¶</a></h2>
<p>For higher-level Fluid ops, such as a few offered by the <code class="docutils literal"><span class="pre">nn</span></code> layer that do not have direct corresponding mappings but can be converted to ONNX by chaining a series of ops without cycles, it would be useful to map them back to the higher-level Fluid ops once converted back from the deprecated ONNX graphs.</p>
<p><em>Resolution</em>: Graphs that have the deprecation from Paddle -&gt; ONNX. When converting back from ONNX, if we encounter the identical graphs by doing a forward search, we can replace the subgraphs with the matching ONNX op.</p>
</div>
</div>
<div class="section" id="supported-models">
<span id="supported-models"></span><h1>Supported models<a class="headerlink" href="#supported-models" title="永久链接至标题">¶</a></h1>
<p>As mentioned above, potential risks may come from the conversion of sequence-related models, including the LodTensor, <code class="docutils literal"><span class="pre">if/else</span></code> and <code class="docutils literal"><span class="pre">while</span></code> operator. So a good choice is to focus on some important feedforward models first, then implement some simple recurrent models.</p>
<ul class="simple">
<li>Feedforward models: common models selected in PaddleBook, e.g. VGG, ResNet and some other models proposed by application teams.</li>
<li>Recurrent models: language model, stacked LSTMs etc.</li>
</ul>
</div>
</div>
<div class="articleComments">
</div>
</div>