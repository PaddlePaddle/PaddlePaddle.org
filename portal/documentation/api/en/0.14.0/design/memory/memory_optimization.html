<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="memory-optimization">
<span id="memory-optimization"></span><h1>Memory Optimization<a class="headerlink" href="#memory-optimization" title="永久链接至标题">¶</a></h1>
<div class="section" id="problem">
<span id="problem"></span><h2>Problem<a class="headerlink" href="#problem" title="永久链接至标题">¶</a></h2>
<p>In a lecture from Andrew Ng, he attributes the recent sucess of AI due to a combination of these:</p>
<ul class="simple">
<li>Availability of Big Data</li>
<li>Supercomputing power to process this Big Data over very large neural networks</li>
<li>Modern algorithms</li>
</ul>
<p>Following graph shows the details:</p>
<p><img alt="" src="../../_images/deep_learning.png"/></p>
<p>Larger model usually bring better performance. However, GPU memory is limited. For example, the memory size of a GTX TITAN X is only 12GB. To train complex and large models, we have to take care of memory usage. Besides, memory optimization is also necessary in both online/mobile inference.</p>
</div>
<div class="section" id="solution">
<span id="solution"></span><h2>Solution<a class="headerlink" href="#solution" title="永久链接至标题">¶</a></h2>
<div class="section" id="basic-strategy">
<span id="basic-strategy"></span><h3>Basic Strategy<a class="headerlink" href="#basic-strategy" title="永久链接至标题">¶</a></h3>
<p>There are some basic strategies to improve memory usage, including in-place operations and memory sharing.</p>
<div class="section" id="in-place-operation">
<span id="in-place-operation"></span><h4>In-place Operation<a class="headerlink" href="#in-place-operation" title="永久链接至标题">¶</a></h4>
<p>In a relu activation operator：</p>
<p>$y = \max(x, 0)$</p>
<p>If the variable x is not used in any other operator, we can make an in-place operation. In other words, the memory block of variable y and variable x will be the same. In-place operations will save 50% memory occupancy immediately.</p>
</div>
<div class="section" id="memory-sharing">
<span id="memory-sharing"></span><h4>Memory Sharing<a class="headerlink" href="#memory-sharing" title="永久链接至标题">¶</a></h4>
<p>Not all operators support in-place operations. Memory sharing is a more general strategy.</p>
<p>Following is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">op1</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">op3</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, variable a is no longer used, and op2 does not support in-place operation. After op2 finishes, we can put the memory of variable a to a memory pool. Then, variable e can share the memory of variable a from the pool.</p>
</div>
</div>
<div class="section" id="live-variable-analysis">
<span id="live-variable-analysis"></span><h3>Live Variable Analysis<a class="headerlink" href="#live-variable-analysis" title="永久链接至标题">¶</a></h3>
<p>It’s not enough to only have some basic strategies. The pre-requisite of memory optimization is to know if a variable is still “live” after an operation.</p>
<p>In our design, the neural network topology is defined as a program. Luckily, <a class="reference external" href="https://en.wikipedia.org/wiki/Live_variable_analysis">live variable analysis</a> is a classic problem in compilers which can be used in many stages, such as register allocation.</p>
<p>In compilers, the front end of the compiler translates programs into an intermediate language with an unbounded number of temporary variables. This program must run on a machine with a bounded number of registers. Two temporary variables a and b can fit into the same register, if a and b are never “in use” at the same time. Thus, many temporary variables can fit in few registers; if they don’t all fit, the excess tempory variables can be kept in memory.</p>
<p>Therefore, the compiler needs to analyze the intermediate-representation program to determine which temporary variables are in use at the same time. We say a variable is “live” if it holds a value that may be needed in the future, so this analysis is called liveness analysis.</p>
<p>We can leran these techniques from compilers. There are mainly two stages to make live variable analysis:</p>
<ul class="simple">
<li>construct a control flow graph</li>
<li>solve the dataflow equations</li>
</ul>
<div class="section" id="control-flow-graph">
<span id="control-flow-graph"></span><h4>Control Flow Graph<a class="headerlink" href="#control-flow-graph" title="永久链接至标题">¶</a></h4>
<p>To perform analysis on a program, it is often useful to make a control flow graph. A <a class="reference external" href="https://en.wikipedia.org/wiki/Control_flow_graph">control flow graph</a> (CFG) in computer science is a representation, using graph notation, of all paths that might be traversed through a program during its execution. Each statement in the program is a node in the flow graph; if statemment x can be followed by statement y, there is an egde from x to y.</p>
<p>Following is the flow graph for a simple loop.</p>
<p><img alt="" src="../../_images/control_flow_graph.png"/></p>
</div>
<div class="section" id="dataflow-analysis">
<span id="dataflow-analysis"></span><h4>Dataflow Analysis<a class="headerlink" href="#dataflow-analysis" title="永久链接至标题">¶</a></h4>
<p>Liveness of variable “flows” around the edges of the control flow graph; determining the live range of each variable is an example of a dataflow problem. <a class="reference external" href="https://en.wikipedia.org/wiki/Data-flow_analysis">Dataflow analysis</a> is a technique for gathering information about the possible set of values calculated at various points in a computer program.</p>
<p>A simple way to perform data-flow analysis of programs is to set up dataflow equations for each node of the control flow graph and solve them by repeatedly calculating the output from the input locally at each node until the whole system stabilizes.</p>
<ul class="simple">
<li>Flow Graph Terminology</li>
</ul>
<p>A flow graph node has out-edges that lead to sucessor nodes, and in-edges that come from predecessor nodes. The set <em>pred[n]</em> is all the predecessors of node n, and <em>succ[n]</em> is the set of sucessors.
In former control flow graph, the out-edges of node 5 are 5 –&gt; 6 and 5 –&gt; 2, and <em>succ[5]</em> = {2, 6}. The in-edges of 2 are 5 –&gt; 2 and 1 –&gt; 2, and <em>pred[2]</em> = {1, 5}.</p>
<ul class="simple">
<li>Uses and Defs</li>
</ul>
<p>An assignmemt to a variable or temporary defines that variable. An occurence of a variable on the right-hand side of an assginment(or in other expressions) uses the variable. We can define the <em>def</em> of a variable as the set of graph nodes that define it; or the <em>def</em> of a graph node as the set of variables that it defines; and the similarly for the <em>use</em> of a variable or graph node. In former control flow graph, <em>def(3)</em> = {c}, <em>use(3)</em> = {b, c}.</p>
<ul class="simple">
<li>Liveness</li>
</ul>
<p>A variable is <em>live</em> on an edge if there is a directed path from that edge to a <em>use</em> of the variable that does not go through any <em>def</em>. A variable is <em>live-in</em> at a node if it is live on any of the in-edges of that node; it is <em>live-out</em> at a node if it is live on any of the out-edges of the node.</p>
<p>The calcution of liveness can be solved by iteration until a fixed pointer is reached. Following is the recursive formula:</p>
<p><img alt="" src="../../_images/dataflow_equations.png"/></p>
</div>
</div>
<div class="section" id="memory-optimization-transpiler">
<span id="memory-optimization-transpiler"></span><h3>Memory optimization transpiler<a class="headerlink" href="#memory-optimization-transpiler" title="永久链接至标题">¶</a></h3>
<p>At last, we take basic strategy and liveness analysis techniques learning from compilers to implement our memory optimization transpiler.</p>
<div class="section" id="add-in-place-attribute">
<span id="add-in-place-attribute"></span><h4>add in-place attribute<a class="headerlink" href="#add-in-place-attribute" title="永久链接至标题">¶</a></h4>
<p>In-place is a built-in attribute of an operator. Since we treat in-place and other operators differently, we have to add an in-place attribute for every operator.</p>
</div>
<div class="section" id="contruct-control-flow-graph">
<span id="contruct-control-flow-graph"></span><h4>contruct control flow graph<a class="headerlink" href="#contruct-control-flow-graph" title="永久链接至标题">¶</a></h4>
<p>Following is the ProgramDesc protobuf of <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/fluid/tests/book/test_machine_translation.py">machine translation</a> example.</p>
<ul class="simple">
<li>Block0:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lookup_table</span>
<span class="n">mul</span>
<span class="o">...</span>
<span class="k">while</span><span class="p">(</span><span class="n">sub</span><span class="o">-</span><span class="n">block</span> <span class="n">idx</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">array_to_lod_tensor</span>
<span class="n">cross_entropy</span>
<span class="o">...</span>
<span class="n">while_grad</span><span class="p">(</span><span class="n">sub</span><span class="o">-</span><span class="n">block</span> <span class="n">idx</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">read_from_array</span>
<span class="n">array_to_lod_tensor</span>
<span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li>Block1</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">read_from_array</span>
<span class="n">read_from_array</span>
<span class="o">...</span>
<span class="n">write_to_array</span>
<span class="n">increment</span>
<span class="n">write_to_array</span>
<span class="n">less_than</span>
</pre></div>
</div>
<ul class="simple">
<li>Block2</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">read_from_array</span>
<span class="n">increment</span>
<span class="o">...</span>
<span class="n">write_to_array</span>
<span class="n">write_to_array</span>
</pre></div>
</div>
<p>We can transfer all the operators and variables in ProgramDesc to build a control flow graph.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ControlFlowGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Program</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sucessors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presucessors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uses</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_live_in</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_live_out</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span> <span class="o">=</span> <span class="n">Program</span>
    
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">dataflow_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">memory_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_program</span>
</pre></div>
</div>
</div>
<div class="section" id="make-dataflow-analysis">
<span id="make-dataflow-analysis"></span><h4>Make dataflow analysis<a class="headerlink" href="#make-dataflow-analysis" title="永久链接至标题">¶</a></h4>
<p>We follow the guide from compilers and try to solve the dataflow equation to get liveness of every variable. If the live-in of an operator node is different from the live-out, then we can make memory sharing.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">op1</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">op3</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The dataflow analysis result is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">live_in</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">}</span>
<span class="n">live_out</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">}</span>

<span class="n">live_in</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">}</span>
<span class="n">live_out</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">}</span>

<span class="n">live_in</span><span class="p">(</span><span class="n">op3</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">}</span>
<span class="n">live_out</span><span class="p">(</span><span class="n">op3</span><span class="p">)</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>After op1, we can process variable b and variable c; After op2, we can process variable a. After op3, we can process variable d and variable f.</p>
</div>
<div class="section" id="memory-sharing-policy">
<span id="memory-sharing-policy"></span><h4>memory sharing policy<a class="headerlink" href="#memory-sharing-policy" title="永久链接至标题">¶</a></h4>
<p>A memory pool will be mantained in the stage of memory optimization. Each operator node will be scanned to determine memory optimization is done or not. If an operator satifies the requirement, following policy will be taken to handle input/output variables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">support_inplace</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">--&gt;</span> <span class="n">pool</span>
    <span class="n">pool</span> <span class="o">--&gt;</span> <span class="n">o</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">--&gt;</span> <span class="n">o</span>
    <span class="n">i</span> <span class="o">--&gt;</span> <span class="n">pool</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="reference">
<span id="reference"></span><h2>Reference<a class="headerlink" href="#reference" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://manavsehgal.com/lecture-notes-from-artificial-intelligence-is-the-new-electricity-by-andrew-ng-4712dcbf26e5">Lecture Notes From Artificial Intelligence Is The New Electricity By Andrew Ng</a></li>
<li>Modern compiler implementation in ML, by Andrew W. Appel</li>
<li><a class="reference external" href="https://mxnet.incubator.apache.org/architecture/note_memory.html">Optimizing Memory Consumption in Deep learning</a></li>
</ul>
</div>
</div>
</div>
<div class="articleComments">
</div>
</div>