<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="backward-building">
<span id="backward-building"></span><h1>Backward Building<a class="headerlink" href="#backward-building" title="永久链接至标题">¶</a></h1>
<div class="section" id="motivation">
<span id="motivation"></span><h2>Motivation<a class="headerlink" href="#motivation" title="永久链接至标题">¶</a></h2>
<p>In Neural Network, most models are solved by the backpropagation algorithm(known as <strong>BP</strong>) at present. Technically, BP calculates the gradient of the loss function, then propagates it back through the networks following the chain rule. However, when configuring the model structure, users do not need to define the backward part. So a mechanism is required by the framework which can complete the model’s backward part automatically according to the given forward part.</p>
<p>When implementing a specific <code class="docutils literal"><span class="pre">op</span></code>, the developer is also asked to implement its backward version, called <code class="docutils literal"><span class="pre">grad_op</span></code>. A <code class="docutils literal"><span class="pre">grad_op</span></code> takes gradients of its corresponding <code class="docutils literal"><span class="pre">op</span></code>‘s outputs, and calculate gradients of the <code class="docutils literal"><span class="pre">op</span></code>‘s inputs. During the building of a model’s backward part, the framework creates each forward <code class="docutils literal"><span class="pre">op</span></code>‘s <code class="docutils literal"><span class="pre">grad_op</span></code>, and then string them together in reverse order of forwarding part. In this way, gradients spread from the end to the beginning of the model, in another word, from the loss to parameters.</p>
</div>
<div class="section" id="challenges">
<span id="challenges"></span><h2>Challenges<a class="headerlink" href="#challenges" title="永久链接至标题">¶</a></h2>
<p>The motivation of backward building is apparent. However, implementation it correctly is not so easy. In the <strong>Fluid</strong> design, a deep learning model is described by <code class="docutils literal"><span class="pre">Program</span></code>, <code class="docutils literal"><span class="pre">Block</span></code>, <code class="docutils literal"><span class="pre">Op</span></code> and <code class="docutils literal"><span class="pre">Variable</span></code>. The <code class="docutils literal"><span class="pre">Block</span></code> itself can be nested. It means that the <code class="docutils literal"><span class="pre">op</span></code>s and <code class="docutils literal"><span class="pre">variable</span></code>s are scattered across different blocks rather than all be gathered in a single graph. Our backward building algorithm shall visit blocks in recursive order and be able to insert <code class="docutils literal"><span class="pre">grad_op</span></code>s and new created <code class="docutils literal"><span class="pre">variable</span></code>s into the right place.</p>
</div>
<div class="section" id="usage">
<span id="usage"></span><h2>Usage<a class="headerlink" href="#usage" title="永久链接至标题">¶</a></h2>
<p>Although the whole algorithm is comprised of many functions, only one is exposed as API:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">append_backward</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">parameter_list</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">no_grad_set</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Append backward part to main_program</span>

<span class="sd">    Args:</span>
<span class="sd">        loss(Variable): The variable generated by the cost function.</span>
<span class="sd">        parameter_list(list): Parameters that need to be updated by optimizers.</span>
<span class="sd">            If None, it means all parameters need to be updated.</span>

<span class="sd">        no_grad_set(set): Variables that have no gradients in Block 0. </span>
<span class="sd">            If None, the set will be generated inside the function and </span>
<span class="sd">            contains all variables with `step_gradient=True` from all blocks.</span>
<span class="sd">        </span>
<span class="sd">    Return:</span>
<span class="sd">        (list[Variable]): list of (parameters, gradients) pair.</span>
<span class="sd">    """</span>
</pre></div>
</div>
<p>By invoking this API, the framework appends backward part of the program where the <code class="docutils literal"><span class="pre">loss</span></code> is. It takes three arguments. <code class="docutils literal"><span class="pre">loss</span></code> means the final loss value. It must be a scalar and is usually the output of the loss layer. It is also where the gradient generated and backpropagation starts. <code class="docutils literal"><span class="pre">parameter_list</span></code> marks all parameters needs updating. If it’s <code class="docutils literal"><span class="pre">None</span></code>, all parameter will be updated by optimizers. <code class="docutils literal"><span class="pre">no_grad_set</span></code> marks variables without gradient. if all outputs of some <code class="docutils literal"><span class="pre">grad_op</span></code> are in <code class="docutils literal"><span class="pre">no_grad_set</span></code>, the <code class="docutils literal"><span class="pre">grad_op</span></code> will not be run.</p>
<p>This API will be invoked automatically before optimizer building.
As a result, in most cases, users do not need to invoke the API by themselves to append backward part.</p>
</div>
<div class="section" id="implementation">
<span id="implementation"></span><h2>Implementation<a class="headerlink" href="#implementation" title="永久链接至标题">¶</a></h2>
<p>The implementation of backward building algorithm is in <code class="docutils literal"><span class="pre">backward.py</span></code> file. The whole algorithm can be divided into two independent parts: creating <code class="docutils literal"><span class="pre">grad_op</span></code>s and creating new variables.</p>
<div class="section" id="creating-grad-ops">
<span id="creating-grad-ops"></span><h3>Creating <code class="docutils literal"><span class="pre">grad_op</span></code>s<a class="headerlink" href="#creating-grad-ops" title="永久链接至标题">¶</a></h3>
<p>The creating of <code class="docutils literal"><span class="pre">grad_op</span></code>s is implemented by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_append_backward_ops_</span><span class="p">(</span><span class="n">target</span><span class="p">,</span>
                          <span class="n">block</span><span class="p">,</span>
                          <span class="n">target_block</span><span class="p">,</span>
                          <span class="n">no_grad_dict</span><span class="p">,</span>
                          <span class="n">grad_to_var</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create all grad ops, and insert them into given block</span>

<span class="sd">    Args:</span>
<span class="sd">        target(Variable): the target variable of forward pass</span>
<span class="sd">        block(Block): the block where forward ops are</span>
<span class="sd">        target_block(Block): the block which is going to hold new generated grad ops</span>
<span class="sd">        no_grad_dict(dict): </span>
<span class="sd">            key(int)  block index</span>
<span class="sd">            val(set) a set of varibale names. These varibales have no gradient</span>
<span class="sd">        grad_to_var(dict)(output argument):</span>
<span class="sd">            key(str): grad variable name</span>
<span class="sd">            val(str): corresponding forward variable name</span>
<span class="sd">    """</span>
</pre></div>
</div>
<p>Given a <code class="docutils literal"><span class="pre">block</span></code>, the function will traverses all <code class="docutils literal"><span class="pre">op</span></code>s in this block in reverse order, gets corresponding <code class="docutils literal"><span class="pre">grad_op</span></code> from the C++ core via <code class="docutils literal"><span class="pre">core.get_grad_op_desc()</span></code>, then append it to <code class="docutils literal"><span class="pre">target_block</span></code>.</p>
<p>However, some specific <code class="docutils literal"><span class="pre">op</span></code>(e.g. <code class="docutils literal"><span class="pre">while_op</span></code>, <code class="docutils literal"><span class="pre">if_else_op</span></code>) can hold its own sub-block. For these sub-blocks contains <code class="docutils literal"><span class="pre">op</span></code>s as well, the <code class="docutils literal"><span class="pre">grad_op</span></code> creating should be recursive.</p>
<p>During the reverse traversal, we check each <code class="docutils literal"><span class="pre">op</span></code> whether it has an attribute named <code class="docutils literal"><span class="pre">sub_block</span></code>. If so, it means there is a sub-block and we need to deal with it first. After creating a new block whose father is the one in <code class="docutils literal"><span class="pre">op</span></code>‘s attribute, we invoke <code class="docutils literal"><span class="pre">_append_backward_ops_()</span></code> recursively, assigning the new block to parameter <code class="docutils literal"><span class="pre">target_block</span></code> and the one in <code class="docutils literal"><span class="pre">op</span></code>‘s attribute to <code class="docutils literal"><span class="pre">block</span></code>. The <em>pseudo-code</em> shows this process:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>******* pseudo-code ********
for op in reversed(block.ops):
    if op has an attribute named 'sub_block':
        Get the sub-block(`s_block`) from op's attribute.
        Create a new block(`grad_s_block`), whose father is `s_block`.
        Invoke _append_backward_ops_(), with `block=s_block` and `target_block=grad_s_block`
    
    Invoke `core.get_grad_op_desc()` to get op's grad_op.
    Insert name correspondings between variables and their gradients of the grad_op to grad_to_var
    Assign grad_s_block to grad_op as it's 'sub_block' attribute.
    Append grad_op to current target_block.
</pre></div>
</div>
<p>The first invoking of <code class="docutils literal"><span class="pre">_append_backward_ops_()</span></code> is initiated by <code class="docutils literal"><span class="pre">append_backward()</span></code>, in which parameters <code class="docutils literal"><span class="pre">block</span></code> and <code class="docutils literal"><span class="pre">target_block</span></code> are all assigned with root block(the block with index 0).</p>
</div>
<div class="section" id="corner-cases-of-grad-op-creating">
<span id="corner-cases-of-grad-op-creating"></span><h3>Corner Cases of <code class="docutils literal"><span class="pre">grad_op</span></code> Creating<a class="headerlink" href="#corner-cases-of-grad-op-creating" title="永久链接至标题">¶</a></h3>
<p>In the previous section, we show the regular process of <code class="docutils literal"><span class="pre">grad_op</span></code> creating. However, in some corner cases, the conventional algorithm is not enough to get the correct result and appending handling is required. These additional processes run after the algorithm mentioned above and do some special adjusts on its output <code class="docutils literal"><span class="pre">grad_op</span></code>s.</p>
<div class="section" id="shared-variables">
<span id="shared-variables"></span><h4>Shared Variables<a class="headerlink" href="#shared-variables" title="永久链接至标题">¶</a></h4>
<p>If a variable is read by more than one <code class="docutils literal"><span class="pre">op</span></code> in the forward pass, its gradient is likely to be written by more than one <code class="docutils literal"><span class="pre">grad_op</span></code>s in the next backward pass. To make the gradient result being the sum of all <code class="docutils literal"><span class="pre">grad_op</span></code>s’ outputs instead of the last running one, we assign each output with a temporary variable and then add a <code class="docutils literal"><span class="pre">sum_op</span></code> to add them up.</p>
<p>For the debug convenience, if the final gradient name is <code class="docutils literal"><span class="pre">w@GRAD</span></code>, it’s corresponding temporary variables will be named as <code class="docutils literal"><span class="pre">w@GRAD@RENAME@0</span></code>, <code class="docutils literal"><span class="pre">w@GRAD@RENAME@1</span></code>...</p>
<p>See function <code class="docutils literal"><span class="pre">_addup_repetitive_outputs_</span></code> in <code class="docutils literal"><span class="pre">backward.py</span></code> for implementation details.</p>
</div>
<div class="section" id="no-gradient-variables">
<span id="no-gradient-variables"></span><h4>No Gradient Variables<a class="headerlink" href="#no-gradient-variables" title="永久链接至标题">¶</a></h4>
<p>In our framework, variables can be marked as <em>no_gradient</em>, it means that the gradient of this variable is unnecessary and can be considered as zero in model training. Apparently, when all the outputs of some <code class="docutils literal"><span class="pre">grad_op</span></code> are marked as <em>no_gradient</em>, the <code class="docutils literal"><span class="pre">grad_op</span></code> itself can be skipped in backward pass.</p>
<p>Another situation is all the gradient inputs of some <code class="docutils literal"><span class="pre">grad_op</span></code> are marked as <em>no_gradient</em>, which means all of them can be considered as zeros. For <code class="docutils literal"><span class="pre">grad_op</span></code>s are in essence the propagation of gradients, all the outputs are definitely zeros when all gradient inputs are zeros. Therefore the <code class="docutils literal"><span class="pre">grad_op</span></code> can also be skipped.</p>
<p>It should be noted that all these zero gradients still need to be creating and initialized by something, otherwise following <code class="docutils literal"><span class="pre">grad_op</span></code>s who take these gradients as inputs take the risk of using uninitialized memory. In our code, we employ <code class="docutils literal"><span class="pre">fill_zeros_like_op</span></code> to initialize them as all zeros.</p>
<p>This features are implemented in function <code class="docutils literal"><span class="pre">_remove_no_grad_branch_</span></code>. It checks new created <code class="docutils literal"><span class="pre">grad_op</span></code>s one-by-one, removes who can be skipped and inserts <code class="docutils literal"><span class="pre">fill_zeros_like_op</span></code> when its necessary. We can get the <code class="docutils literal"><span class="pre">no_grad_set</span></code> from the <code class="docutils literal"><span class="pre">_append_backward_ops_</span></code> argument <code class="docutils literal"><span class="pre">no_grad_dict</span></code> or generate it on the fly by scanning all variables’ <code class="docutils literal"><span class="pre">no_gradient</span></code> attribute(True or False).</p>
</div>
</div>
<div class="section" id="creating-backward-variables">
<span id="creating-backward-variables"></span><h3>Creating Backward Variables<a class="headerlink" href="#creating-backward-variables" title="永久链接至标题">¶</a></h3>
<p>Up to now, we have completed all creating and adjusting jobs of <code class="docutils literal"><span class="pre">grad_op</span></code>s. However, backward variables have not been created. Now they are only represented by <code class="docutils literal"><span class="pre">grad_op</span></code>‘s input and output arguments. The backward variable creating job will be done by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_append_backward_vars_</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> 
                           <span class="n">start_op_idx</span><span class="p">,</span> 
                           <span class="n">grad_to_var</span><span class="p">,</span> 
                           <span class="n">grad_info_map</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create new variables required by backward pass.</span>

<span class="sd">    Args:</span>
<span class="sd">        block(Block): the block where new variables will be created</span>
<span class="sd">        start_op_idx(int): Only variables required by ops in block.ops[start_op_idx : ] will be created</span>
<span class="sd">        grad_to_var(dict):</span>
<span class="sd">            key(str): grad variable name</span>
<span class="sd">            val(str): corresponding forward variable name</span>
<span class="sd">            In most cases, this dict is generated by _append_backward_ops_()</span>
<span class="sd">        grad_info_map(dict)(output argument):</span>
<span class="sd">            key(str): forward variable name</span>
<span class="sd">            val(tuple): a tuple of (str, int), str is the corresponding grad name, int is the block index</span>
<span class="sd">    """</span>
</pre></div>
</div>
<p>Given a <code class="docutils literal"><span class="pre">block</span></code>, this function traverses all the <code class="docutils literal"><span class="pre">grad_op</span></code>s in it(The argument <code class="docutils literal"><span class="pre">start_op_idx</span></code> indicates where the grad_op sequence starts.) and creates all the uncreated outputs. The <em>pseudo-code</em> shows this process:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for op in block.ops[start_op_idx : ]:

    if op has an attribute named 'sub_block':
        Get the sub-block(`s_block`) from op's attribute.
        Invoke _append_backward_vars_(), with `block=s_block`
        
    for var_name in op.all_output_names():
        if block.has_var_recursive(var_name) or var_name is the name of empty variable:
            continue
        create a new variable named 'var_name' in block
        if grad_to_var.has_key(var_name):
            set grad_info_map[grad_to_var[var_name]] as a tuple of (var_name. block)
            
    do op's var type inference
    do op's shape inference
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="articleComments">
</div>
</div>