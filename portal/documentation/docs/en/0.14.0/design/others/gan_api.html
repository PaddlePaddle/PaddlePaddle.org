{% verbatim %}
<h1>Design for GAN</h1>
<p>GAN (General Adversarial Net [https://arxiv.org/abs/1406.2661]) is an important model for unsupervised learning and widely used in many areas.</p>
<p>It applies several important concepts in machine learning system design, including building and running subgraphs, dependency tracing, different optimizers in one executor and so forth.</p>
<p>In our GAN design, we wrap it as a user-friendly easily customized python API to design different models. We take the conditional DC-GAN (Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks [https://arxiv.org/abs/1511.06434]) as an example due to its good performance on image generation.</p>
<p align="center">
<img src="https://raw.githubusercontent.com/PaddlePaddle/Paddle/develop/doc/fluid/images/test.dot.png" width = "35%" align="center"/><br/>
Figure 1. The overall running logic of GAN. The black solid arrows indicate the forward pass; the green dashed arrows indicate the backward pass of generator training; the red dashed arrows indicate the backward pass of the discriminator training. The BP pass of the green (red) arrow should only update the parameters in the green (red) boxes. The diamonds indicate the data providers. d\_loss and g\_loss marked in red and green are the two targets we would like to run.
</p>

<p>The operators, layers and functions required/optional to build a GAN demo is summarized in https://github.com/PaddlePaddle/Paddle/issues/4563.</p>
<p align="center">
<img src="https://raw.githubusercontent.com/PaddlePaddle/Paddle/develop/doc/fluid/images/dcgan.png" width = "90%" align="center"/><br/>
Figure 2. Photo borrowed from the original DC-GAN paper.
</p>

<h2>The Conditional-GAN might be a class.</h2>
<p>This design we adopt the popular open source design in https://github.com/carpedm20/DCGAN-tensorflow and https://github.com/rajathkmp/DCGAN. It contains following data structure:</p>
<ul>
<li>
<p>DCGAN(object): which contains everything required to build a GAN model. It provides following member functions methods as API:</p>
</li>
<li>
<p><strong>init</strong>(...): Initialize hyper-parameters (like conv dimension and so forth), and declare model parameters of discriminator and generator as well.</p>
</li>
<li>
<p>generator(z, y=None): Generate a fake image from input noise z. If the label y is provided, the conditional GAN model will be chosen.
Returns a generated image.</p>
</li>
<li>
<p>discriminator(image):
Given an image, decide if it is from a real source or a fake one.
Returns a 0/1 binary label.</p>
</li>
<li>
<p>build_model(self):
build the whole GAN model, define training loss for both generator and discrimator.</p>
</li>
</ul>
<h2>Discussion on Engine Functions required to build GAN</h2>
<ul>
<li>Trace the tensor and variable dependency in the engine executor. (Very critical, otherwise GAN can'be be trained correctly)</li>
<li>Different optimizers responsible for optimizing different loss.</li>
</ul>
<p>To be more detailed, we introduce our design of DCGAN as following:</p>
<h3>Class member Function: Initializer</h3>
<ul>
<li>Set up hyper-parameters, including condtional dimension, noise dimension, batch size and so forth.</li>
<li>Declare and define all the model variables. All the discriminator parameters are included in the list self.theta_D and all the generator parameters are included in the list self.theta_G.
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DCGAN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="c1"># hyper parameters  </span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span> <span class="o">=</span> <span class="n">y_dim</span> <span class="c1"># conditional gan or not</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">z_dim</span> <span class="o">=</span> <span class="n">z_dim</span> <span class="c1"># input noise dimension</span>

    <span class="c1"># define parameters of discriminators</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_W0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">gaussian_normal_randomizer</span><span class="p">())</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_b0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span> <span class="c1"># variable also support initialization using a  numpy data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_W1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">784</span><span class="p">,</span> <span class="mi">128</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">gaussian_normal_randomizer</span><span class="p">())</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_b1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span> <span class="c1"># variable also support initialization using a  numpy data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_W2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Varialble</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D_b2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">theta_D</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">D_W0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_b0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_W1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_W2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_b2</span><span class="p">]</span>

    <span class="c1"># define parameters of generators</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_W0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">784</span><span class="p">,</span> <span class="mi">128</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">gaussian_normal_randomizer</span><span class="p">())</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_b0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span> <span class="c1"># variable also support initialization using a  numpy data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_W1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">784</span><span class="p">,</span> <span class="mi">128</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">gaussian_normal_randomizer</span><span class="p">())</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_b1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span> <span class="c1"># variable also support initialization using a  numpy data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_W2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Varialble</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G_b2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">theta_G</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G_W0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_W1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_W2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b2</span><span class="p">]</span>
</pre></div></li>
</ul>
<h3>Class member Function: Generator</h3>
<ul>
<li>Given a noisy input z, returns a fake image.</li>
<li>Concatenation, batch-norm, FC operations required;</li>
<li>Deconv layer required, which is missing now...
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DCGAN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="c1"># input z: the random noise</span>
    <span class="c1"># input y: input data label (optional)</span>
    <span class="c1"># output G_im: generated fake images</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

    <span class="n">G_h0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_w0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b0</span><span class="p">)</span>
    <span class="n">G_h0_bn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">(</span><span class="n">G_h0</span><span class="p">)</span>
    <span class="n">G_h0_relu</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">G_h0_bn</span><span class="p">)</span>

    <span class="n">G_h1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">deconv</span><span class="p">(</span><span class="n">G_h0_relu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_w1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b1</span><span class="p">)</span>
    <span class="n">G_h1_bn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">(</span><span class="n">G_h1</span><span class="p">)</span>
    <span class="n">G_h1_relu</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">G_h1_bn</span><span class="p">)</span>

    <span class="n">G_h2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">deconv</span><span class="p">(</span><span class="n">G_h1_relu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_W2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_b2</span><span class="p">))</span>
    <span class="n">G_im</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">G_im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_im</span>
</pre></div></li>
</ul>
<h3>Class member function: Discriminator</h3>
<ul>
<li>Given a noisy input z, returns a fake image.</li>
<li>Concatenation, Convolution, batch-norm, FC, Leaky-ReLU operations required;
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DCGAN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="c1"># input image: either generated images or real ones</span>
    <span class="c1"># output D_h2: binary logit of the label</span>

    <span class="n">D_h0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_w0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_b0</span><span class="p">)</span>
    <span class="n">D_h0_bn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">batchnorm</span><span class="p">(</span><span class="n">h0</span><span class="p">)</span>
    <span class="n">D_h0_relu</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">lrelu</span><span class="p">(</span><span class="n">h0_bn</span><span class="p">)</span>

    <span class="n">D_h1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">D_h0_relu</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_w1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_b1</span><span class="p">)</span>
    <span class="n">D_h1_bn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">batchnorm</span><span class="p">(</span><span class="n">D_h1</span><span class="p">)</span>
    <span class="n">D_h1_relu</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">lrelu</span><span class="p">(</span><span class="n">D_h1_bn</span><span class="p">)</span>

    <span class="n">D_h2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">D_h1_relu</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_w2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D_b2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">D_h2</span>
</pre></div></li>
</ul>
<h3>Class member function: Build the model</h3>
<ul>
<li>Define data readers as placeholders to hold the data;</li>
<li>Build generator and discriminators;</li>
<li>Define two training losses for discriminator and generator, respectively.
If we have execution dependency engine to back-trace all tensors, the module building our GAN model will be like this:
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DCGAN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">faked_images</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">])</span>

    <span class="c1"># step 1: generate images by generator, classify real/fake images with discriminator</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span> <span class="c1"># if conditional GAN, includes label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="c1"># generated fake images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># original version of GAN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="c1"># generate fake images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>

    <span class="c1"># step 2: define the two losses</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_fake</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">d_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_real</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_fake</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">g_loss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_szie</span><span class="p">))</span>
</pre></div></li>
</ul>
<p>If we do not have dependency engine but blocks, the module building our GAN model will be like this:
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DCGAN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_block</span><span class="p">):</span>
    <span class="c1"># input data in the default block</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_size</span><span class="p">])</span>
    <span class="c1"># self.faked_images = pd.data(pd.float32, [self.batch_size, self.im_size, self.im_size])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">])</span>

    <span class="c1"># step 1: generate images by generator, classify real/fake images with discriminator</span>
    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">default_block</span><span class="p">()</span><span class="o">.</span><span class="n">g_block</span><span class="p">():</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span> <span class="c1"># if conditional GAN, includes label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1"># original version of GAN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">g_loss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_g</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_szie</span><span class="p">))</span>

    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">default_block</span><span class="p">()</span><span class="o">.</span><span class="n">d_block</span><span class="p">():</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span> <span class="c1"># if conditional GAN, includes label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1"># original version of GAN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>

      <span class="c1"># step 2: define the two losses</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">))</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_fake</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">))</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">d_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_real</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_loss_fake</span>
</pre></div>
Some small confusion and problems with this design:
- D_g and D_f are actually the same thing, but has to be written twice; i.e., if we want to run two sub-graphs conceptually, the same codes have to be written twice if they are shared by the graph.
- Requires ability to create a block anytime, rather than in if-else or rnn only;</p>
<h2>Main function for the demo:</h2>
<p>Generally, the user of GAN just need to the following things:
- Define an object as DCGAN class;
- Build the DCGAN model;
- Specify two optimizers for two different losses with respect to different parameters.
<div class="highlight"><pre><span></span><span class="c1"># pd for short, should be more concise.</span>
<span class="kn">from</span> <span class="nn">paddle.v2</span> <span class="nn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># dcgan class in the default graph/block</span>
    <span class="c1"># if we use dependency engine as tensorflow</span>
    <span class="c1"># the codes, will be slightly different like:</span>
    <span class="c1"># dcgan = DCGAN()</span>
    <span class="c1"># dcgan.build_model()</span>
    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">block</span><span class="p">()</span> <span class="k">as</span> <span class="n">def_block</span><span class="p">:</span>
      <span class="n">dcgan</span> <span class="o">=</span> <span class="n">DCGAN</span><span class="p">()</span>
      <span class="n">dcgan</span><span class="o">.</span><span class="n">build_model</span><span class="p">(</span><span class="n">def_block</span><span class="p">)</span>

    <span class="c1"># load mnist data</span>
    <span class="n">data_X</span><span class="p">,</span> <span class="n">data_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_mnist</span><span class="p">()</span>

    <span class="c1"># Two subgraphs required!!!</span>
    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">block</span><span class="p">()</span><span class="o">.</span><span class="n">d_block</span><span class="p">():</span>
      <span class="n">d_optim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">lr</span> <span class="o">=</span> <span class="o">.</span><span class="mo">001</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">d_step</span> <span class="o">=</span> <span class="n">d_optim</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">dcgan</span><span class="o">.</span><span class="n">d_loss</span><span class="p">,</span> <span class="n">dcgan</span><span class="o">.</span><span class="n">theta_D</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">g_block</span><span class="p">():</span>
      <span class="n">g_optim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">lr</span> <span class="o">=</span> <span class="o">.</span><span class="mo">001</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">g_step</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">dcgan</span><span class="o">.</span><span class="n">g_loss</span><span class="p">,</span> <span class="n">dcgan</span><span class="o">.</span><span class="n">theta_G</span><span class="p">)</span>

    <span class="c1"># executor</span>
    <span class="n">sess</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">executor</span><span class="p">()</span>

    <span class="c1"># training</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">batch_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="o">...</span>
        <span class="c1"># sample a batch</span>
        <span class="n">batch_im</span><span class="p">,</span> <span class="n">batch_label</span> <span class="o">=</span> <span class="n">data_X</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">batch_size</span><span class="p">],</span> <span class="n">data_y</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">batch_size</span><span class="p">]</span>
        <span class="c1"># sample z</span>
        <span class="n">batch_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">batch_id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">d_step</span><span class="p">,</span>
                   <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">dcgan</span><span class="o">.</span><span class="n">images</span><span class="p">:</span> <span class="n">batch_im</span><span class="p">,</span>
                                <span class="n">dcgan</span><span class="o">.</span><span class="n">y</span><span class="p">:</span> <span class="n">batch_label</span><span class="p">,</span>
                                <span class="n">dcgan</span><span class="o">.</span><span class="n">z</span><span class="p">:</span> <span class="n">batch_z</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">g_step</span><span class="p">,</span>
                   <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">dcgan</span><span class="o">.</span><span class="n">z</span><span class="p">:</span> <span class="n">batch_z</span><span class="p">})</span>
</pre></div></p>
<h1>More thinking about dependency engine v.s. block design:</h1>
<ul>
<li>What if we just want to run an intermediate result? Do we need to run the whole block/graph?</li>
<li>Should we call eval() to get the fake images in the first stage? And then train the discriminator in the second stage?</li>
</ul>
{% endverbatim %}