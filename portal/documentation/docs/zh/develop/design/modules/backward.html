{% verbatim %}
<h1>Backward Building</h1>
<h2>Motivation</h2>
<p>In Neural Network, most models are solved by the backpropagation algorithm(known as <strong>BP</strong>) at present. Technically, BP calculates the gradient of the loss function, then propagates it back through the networks following the chain rule. However, when configuring the model structure, users do not need to define the backward part. So a mechanism is required by the framework which can complete the model's backward part automatically according to the given forward part.</p>
<p>When implementing a specific <code>op</code>, the developer is also asked to implement its backward version, called <code>grad_op</code>. A <code>grad_op</code> takes gradients of its corresponding <code>op</code>'s outputs, and calculate gradients of the <code>op</code>'s inputs. During the building of a model's backward part, the framework creates each forward <code>op</code>'s <code>grad_op</code>, and then string them together in reverse order of forwarding part. In this way, gradients spread from the end to the beginning of the model, in another word, from the loss to parameters.</p>
<h2>Challenges</h2>
<p>The motivation of backward building is apparent. However, implementation it correctly is not so easy. In the <strong>Fluid</strong> design, a deep learning model is described by <code>Program</code>, <code>Block</code>, <code>Op</code> and <code>Variable</code>. The <code>Block</code> itself can be nested. It means that the <code>op</code>s and <code>variable</code>s are scattered across different blocks rather than all be gathered in a single graph. Our backward building algorithm shall visit blocks in recursive order and be able to insert <code>grad_op</code>s and new created <code>variable</code>s into the right place. </p>
<h2>Usage</h2>
<p>Although the whole algorithm is comprised of many functions, only one is exposed as API:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">append_backward</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">parameter_list</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">no_grad_set</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append backward part to main_program</span>

<span class="sd">    Args:</span>
<span class="sd">        loss(Variable): The variable generated by the cost function.</span>
<span class="sd">        parameter_list(list): Parameters that need to be updated by optimizers.</span>
<span class="sd">            If None, it means all parameters need to be updated.</span>

<span class="sd">        no_grad_set(set): Variables that have no gradients in Block 0. </span>
<span class="sd">            If None, the set will be generated inside the function and </span>
<span class="sd">            contains all variables with `step_gradient=True` from all blocks.</span>

<span class="sd">    Return:</span>
<span class="sd">        (list[Variable]): list of (parameters, gradients) pair.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>

<p>By invoking this API, the framework appends backward part of the program where the <code>loss</code> is. It takes three arguments. <code>loss</code> means the final loss value. It must be a scalar and is usually the output of the loss layer. It is also where the gradient generated and backpropagation starts. <code>parameter_list</code> marks all parameters needs updating. If it's <code>None</code>, all parameter will be updated by optimizers. <code>no_grad_set</code> marks variables without gradient. if all outputs of some <code>grad_op</code> are in <code>no_grad_set</code>, the <code>grad_op</code> will not be run.</p>
<p>This API will be invoked automatically before optimizer building. 
As a result, in most cases, users do not need to invoke the API by themselves to append backward part.</p>
<h2>Implementation</h2>
<p>The implementation of backward building algorithm is in <code>backward.py</code> file. The whole algorithm can be divided into two independent parts: creating <code>grad_op</code>s and creating new variables. </p>
<h3>Creating <code>grad_op</code>s</h3>
<p>The creating of <code>grad_op</code>s is implemented by:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_append_backward_ops_</span><span class="p">(</span><span class="n">target</span><span class="p">,</span>
                          <span class="n">block</span><span class="p">,</span>
                          <span class="n">target_block</span><span class="p">,</span>
                          <span class="n">no_grad_dict</span><span class="p">,</span>
                          <span class="n">grad_to_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create all grad ops, and insert them into given block</span>

<span class="sd">    Args:</span>
<span class="sd">        target(Variable): the target variable of forward pass</span>
<span class="sd">        block(Block): the block where forward ops are</span>
<span class="sd">        target_block(Block): the block which is going to hold new generated grad ops</span>
<span class="sd">        no_grad_dict(dict): </span>
<span class="sd">            key(int)  block index</span>
<span class="sd">            val(set) a set of varibale names. These varibales have no gradient</span>
<span class="sd">        grad_to_var(dict)(output argument):</span>
<span class="sd">            key(str): grad variable name</span>
<span class="sd">            val(str): corresponding forward variable name</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>

<p>Given a <code>block</code>, the function will traverses all <code>op</code>s in this block in reverse order, gets corresponding <code>grad_op</code> from the C++ core via <code>core.get_grad_op_desc()</code>, then append it to <code>target_block</code>. </p>
<p>However, some specific <code>op</code>(e.g. <code>while_op</code>, <code>if_else_op</code>) can hold its own sub-block. For these sub-blocks contains <code>op</code>s as well, the <code>grad_op</code> creating should be recursive.</p>
<p>During the reverse traversal, we check each <code>op</code> whether it has an attribute named <code>sub_block</code>. If so, it means there is a sub-block and we need to deal with it first. After creating a new block whose father is the one in <code>op</code>'s attribute, we invoke <code>_append_backward_ops_()</code> recursively, assigning the new block to parameter <code>target_block</code> and the one in <code>op</code>'s attribute to <code>block</code>. The <em>pseudo-code</em> shows this process:</p>
<div class="highlight"><pre><span></span>******* pseudo-code ********
for op in reversed(block.ops):
    if op has an attribute named &#39;sub_block&#39;:
        Get the sub-block(`s_block`) from op&#39;s attribute.
        Create a new block(`grad_s_block`), whose father is `s_block`.
        Invoke _append_backward_ops_(), with `block=s_block` and `target_block=grad_s_block`

    Invoke `core.get_grad_op_desc()` to get op&#39;s grad_op.
    Insert name correspondings between variables and their gradients of the grad_op to grad_to_var
    Assign grad_s_block to grad_op as it&#39;s &#39;sub_block&#39; attribute.
    Append grad_op to current target_block.
</pre></div>

<p>The first invoking of <code>_append_backward_ops_()</code> is initiated by <code>append_backward()</code>, in which parameters <code>block</code> and <code>target_block</code> are all assigned with root block(the block with index 0).</p>
<h3>Corner Cases of <code>grad_op</code> Creating</h3>
<p>In the previous section, we show the regular process of <code>grad_op</code> creating. However, in some corner cases, the conventional algorithm is not enough to get the correct result and appending handling is required. These additional processes run after the algorithm mentioned above and do some special adjusts on its output <code>grad_op</code>s.</p>
<h4>Shared Variables</h4>
<p>If a variable is read by more than one <code>op</code> in the forward pass, its gradient is likely to be written by more than one <code>grad_op</code>s in the next backward pass. To make the gradient result being the sum of all <code>grad_op</code>s' outputs instead of the last running one, we assign each output with a temporary variable and then add a <code>sum_op</code> to add them up. </p>
<p>For the debug convenience, if the final gradient name is <code>w@GRAD</code>, it's corresponding temporary variables will be named as <code>w@GRAD@RENAME@0</code>, <code>w@GRAD@RENAME@1</code>...</p>
<p>See function <code>_addup_repetitive_outputs_</code> in <code>backward.py</code> for implementation details.</p>
<h4>No Gradient Variables</h4>
<p>In our framework, variables can be marked as <em>no_gradient</em>, it means that the gradient of this variable is unnecessary and can be considered as zero in model training. Apparently, when all the outputs of some <code>grad_op</code> are marked as <em>no_gradient</em>, the <code>grad_op</code> itself can be skipped in backward pass. </p>
<p>Another situation is all the gradient inputs of some <code>grad_op</code> are marked as <em>no_gradient</em>, which means all of them can be considered as zeros. For <code>grad_op</code>s are in essence the propagation of gradients, all the outputs are definitely zeros when all gradient inputs are zeros. Therefore the <code>grad_op</code> can also be skipped.</p>
<p>It should be noted that all these zero gradients still need to be creating and initialized by something, otherwise following <code>grad_op</code>s who take these gradients as inputs take the risk of using uninitialized memory. In our code, we employ <code>fill_zeros_like_op</code> to initialize them as all zeros. </p>
<p>This features are implemented in function <code>_remove_no_grad_branch_</code>. It checks new created <code>grad_op</code>s one-by-one, removes who can be skipped and inserts <code>fill_zeros_like_op</code> when its necessary. We can get the <code>no_grad_set</code> from the <code>_append_backward_ops_</code> argument <code>no_grad_dict</code> or generate it on the fly by scanning all variables' <code>no_gradient</code> attribute(True or False). </p>
<h3>Creating Backward Variables</h3>
<p>Up to now, we have completed all creating and adjusting jobs of <code>grad_op</code>s. However, backward variables have not been created. Now they are only represented by <code>grad_op</code>'s input and output arguments. The backward variable creating job will be done by:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_append_backward_vars_</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> 
                           <span class="n">start_op_idx</span><span class="p">,</span> 
                           <span class="n">grad_to_var</span><span class="p">,</span> 
                           <span class="n">grad_info_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create new variables required by backward pass.</span>

<span class="sd">    Args:</span>
<span class="sd">        block(Block): the block where new variables will be created</span>
<span class="sd">        start_op_idx(int): Only variables required by ops in block.ops[start_op_idx : ] will be created</span>
<span class="sd">        grad_to_var(dict):</span>
<span class="sd">            key(str): grad variable name</span>
<span class="sd">            val(str): corresponding forward variable name</span>
<span class="sd">            In most cases, this dict is generated by _append_backward_ops_()</span>
<span class="sd">        grad_info_map(dict)(output argument):</span>
<span class="sd">            key(str): forward variable name</span>
<span class="sd">            val(tuple): a tuple of (str, int), str is the corresponding grad name, int is the block index</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>

<p>Given a <code>block</code>, this function traverses all the <code>grad_op</code>s in it(The argument <code>start_op_idx</code> indicates where the grad_op sequence starts.) and creates all the uncreated outputs. The <em>pseudo-code</em> shows this process:</p>
<div class="highlight"><pre><span></span>for op in block.ops[start_op_idx : ]:

    if op has an attribute named &#39;sub_block&#39;:
        Get the sub-block(`s_block`) from op&#39;s attribute.
        Invoke _append_backward_vars_(), with `block=s_block`

    for var_name in op.all_output_names():
        if block.has_var_recursive(var_name) or var_name is the name of empty variable:
            continue
        create a new variable named &#39;var_name&#39; in block
        if grad_to_var.has_key(var_name):
            set grad_info_map[grad_to_var[var_name]] as a tuple of (var_name. block)

    do op&#39;s var type inference
    do op&#39;s shape inference
</pre></div>
{% endverbatim %}