{% verbatim %}
<h1>情感分析</h1>
<p>本教程源代码目录在<a href="https://github.com/PaddlePaddle/book/tree/develop/06.understand_sentiment">book/understand_sentiment</a>， 初次使用请参考PaddlePaddle<a href="https://github.com/PaddlePaddle/book/blob/develop/README.cn.md#运行这本书">安装教程</a>，更多内容请参考本教程的<a href="http://bit.baidu.com/course/detail/id/177.html">视频课堂</a>。</p>
<h2>背景介绍</h2>
<p>在自然语言处理中，情感分析一般是指判断一段文本所表达的情绪状态。其中，一段文本可以是一个句子，一个段落或一个文档。情绪状态可以是两类，如（正面，负面），（高兴，悲伤）；也可以是三类，如（积极，消极，中性）等等。情感分析的应用场景十分广泛，如把用户在购物网站（亚马逊、天猫、淘宝等）、旅游网站、电影评论网站上发表的评论分成正面评论和负面评论；或为了分析用户对于某一产品的整体使用感受，抓取产品的用户评论并进行情感分析等等。表格1展示了对电影评论进行情感分析的例子：</p>
<table>
<thead>
<tr>
<th>电影评论</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>在冯小刚这几年的电影里，算最好的一部的了</td>
<td>正面</td>
</tr>
<tr>
<td>很不好看，好像一个地方台的电视剧</td>
<td>负面</td>
</tr>
<tr>
<td>圆方镜头全程炫技，色调背景美则美矣，但剧情拖沓，口音不伦不类，一直努力却始终无法入戏</td>
<td>负面</td>
</tr>
<tr>
<td>剧情四星。但是圆镜视角加上婺源的风景整个非常有中国写意山水画的感觉，看得实在太舒服了。。</td>
<td>正面</td>
</tr>
</tbody>
</table>
<p align="center">表格 1 电影评论情感分析</p>
<p>在自然语言处理中，情感分析属于典型的<strong>文本分类</strong>问题，即把需要进行情感分析的文本划分为其所属类别。文本分类涉及文本表示和分类方法两个问题。在深度学习的方法出现之前，主流的文本表示方法为词袋模型BOW(bag of words)，话题模型等等；分类方法有SVM(support vector machine), LR(logistic regression)等等。  </p>
<p>对于一段文本，BOW表示会忽略其词顺序、语法和句法，将这段文本仅仅看做是一个词集合，因此BOW方法并不能充分表示文本的语义信息。例如，句子“这部电影糟糕透了”和“一个乏味，空洞，没有内涵的作品”在情感分析中具有很高的语义相似度，但是它们的BOW表示的相似度为0。又如，句子“一个空洞，没有内涵的作品”和“一个不空洞而且有内涵的作品”的BOW相似度很高，但实际上它们的意思很不一样。  </p>
<p>本章我们所要介绍的深度学习模型克服了BOW表示的上述缺陷，它在考虑词顺序的基础上把文本映射到低维度的语义空间，并且以端对端（end to end）的方式进行文本表示及分类，其性能相对于传统方法有显著的提升[<a href="#参考文献">1</a>]。</p>
<h2>模型概览</h2>
<p>本章所使用的文本表示模型为卷积神经网络（Convolutional Neural Networks）和循环神经网络(Recurrent Neural Networks)及其扩展。下面依次介绍这几个模型。</p>
<h3>文本卷积神经网络简介（CNN）</h3>
<p>我们在<a href="https://github.com/PaddlePaddle/book/tree/develop/05.recommender_system">推荐系统</a>一节介绍过应用于文本数据的卷积神经网络模型的计算过程，这里进行一个简单的回顾。</p>
<p>对卷积神经网络来说，首先使用卷积处理输入的词向量序列，产生一个特征图（feature map），对特征图采用时间维度上的最大池化（max pooling over time）操作得到此卷积核对应的整句话的特征，最后，将所有卷积核得到的特征拼接起来即为文本的定长向量表示，对于文本分类问题，将其连接至softmax即构建出完整的模型。在实际应用中，我们会使用多个卷积核来处理句子，窗口大小相同的卷积核堆叠起来形成一个矩阵，这样可以更高效的完成运算。另外，我们也可使用窗口大小不同的卷积核来处理句子，<a href="https://github.com/PaddlePaddle/book/tree/develop/05.recommender_system">推荐系统</a>一节的图3作为示意画了四个卷积核，不同颜色表示不同大小的卷积核操作。</p>
<p>对于一般的短文本分类问题，上文所述的简单的文本卷积网络即可达到很高的正确率[<a href="#参考文献">1</a>]。若想得到更抽象更高级的文本特征表示，可以构建深层文本卷积神经网络[<a href="#参考文献">2</a>,<a href="#参考文献">3</a>]。</p>
<h3>循环神经网络（RNN）</h3>
<p>循环神经网络是一种能对序列数据进行精确建模的有力工具。实际上，循环神经网络的理论计算能力是图灵完备的[<a href="#参考文献">4</a>]。自然语言是一种典型的序列数据（词序列），近年来，循环神经网络及其变体（如long short term memory[<a href="#参考文献">5</a>]等）在自然语言处理的多个领域，如语言模型、句法解析、语义角色标注（或一般的序列标注）、语义表示、图文生成、对话、机器翻译等任务上均表现优异甚至成为目前效果最好的方法。</p>
<p align="center">
<img align="center" src="image/rnn.png" width="60%"/><br/>
图1. 循环神经网络按时间展开的示意图
</p>
<p>循环神经网络按时间展开后如图1所示：在第<span class="markdown-equation" id="equation-0">$t$</span>时刻，网络读入第<span class="markdown-equation" id="equation-0">$t$</span>个输入<span class="markdown-equation" id="equation-2">$x_t$</span>（向量表示）及前一时刻隐层的状态值<span class="markdown-equation" id="equation-3">$h_{t-1}$</span>（向量表示，<span class="markdown-equation" id="equation-4">$h_0$</span>一般初始化为<span class="markdown-equation" id="equation-5">$0$</span>向量），计算得出本时刻隐层的状态值<span class="markdown-equation" id="equation-6">$h_t$</span>，重复这一步骤直至读完所有输入。如果将循环神经网络所表示的函数记为<span class="markdown-equation" id="equation-7">$f$</span>，则其公式可表示为：</p>
<p><span class="markdown-equation" id="equation-8">$$h_t=f(x_t,h_{t-1})=\sigma(W_{xh}x_t+W_{hh}h_{h-1}+b_h)$$</span></p>
<p>其中<span class="markdown-equation" id="equation-9">$W_{xh}$</span>是输入到隐层的矩阵参数，<span class="markdown-equation" id="equation-10">$W_{hh}$</span>是隐层到隐层的矩阵参数，<span class="markdown-equation" id="equation-11">$b_h$</span>为隐层的偏置向量（bias）参数，<span class="markdown-equation" id="equation-12">$\sigma$</span>为<span class="markdown-equation" id="equation-13">$sigmoid$</span>函数。  </p>
<p>在处理自然语言时，一般会先将词（one-hot表示）映射为其词向量（word embedding）表示，然后再作为循环神经网络每一时刻的输入<span class="markdown-equation" id="equation-2">$x_t$</span>。此外，可以根据实际需要的不同在循环神经网络的隐层上连接其它层。如，可以把一个循环神经网络的隐层输出连接至下一个循环神经网络的输入构建深层（deep or stacked）循环神经网络，或者提取最后一个时刻的隐层状态作为句子表示进而使用分类模型等等。  </p>
<h3>长短期记忆网络（LSTM）</h3>
<p>对于较长的序列数据，循环神经网络的训练过程中容易出现梯度消失或爆炸现象[<a href="#参考文献">6</a>]。为了解决这一问题，Hochreiter S, Schmidhuber J. (1997)提出了LSTM(long short term memory[<a href="#参考文献">5</a>])。  </p>
<p>相比于简单的循环神经网络，LSTM增加了记忆单元<span class="markdown-equation" id="equation-15">$c$</span>、输入门<span class="markdown-equation" id="equation-16">$i$</span>、遗忘门<span class="markdown-equation" id="equation-7">$f$</span>及输出门<span class="markdown-equation" id="equation-18">$o$</span>。这些门及记忆单元组合起来大大提升了循环神经网络处理长序列数据的能力。若将基于LSTM的循环神经网络表示的函数记为<span class="markdown-equation" id="equation-19">$F$</span>，则其公式为：</p>
<p><span class="markdown-equation" id="equation-20">$$ h_t=F(x_t,h_{t-1})$$</span></p>
<p><span class="markdown-equation" id="equation-19">$F$</span>由下列公式组合而成[<a href="#参考文献">7</a>]：
begin{align}
i_t &amp; = sigma(W_{xi}x_t+W_{hi}h_{h-1}+W_{ci}c_{t-1}+b_i)\\
f_t &amp; = sigma(W_{xf}x_t+W_{hf}h_{h-1}+W_{cf}c_{t-1}+b_f)\\
c_t &amp; = f_todot c_{t-1}+i_todot tanh(W_{xc}x_t+W_{hc}h_{h-1}+b_c)\\
o_t &amp; = sigma(W_{xo}x_t+W_{ho}h_{h-1}+W_{co}c_{t}+b_o)\\
h_t &amp; = o_todot tanh(c_t)\\
end{align}
其中，<span class="markdown-equation" id="equation-22">$i_t, f_t, c_t, o_t$</span>分别表示输入门，遗忘门，记忆单元及输出门的向量值，带角标的<span class="markdown-equation" id="equation-23">$W$</span>及<span class="markdown-equation" id="equation-24">$b$</span>为模型参数，<span class="markdown-equation" id="equation-25">$tanh$</span>为双曲正切函数，<span class="markdown-equation" id="equation-26">$\odot$</span>表示逐元素（elementwise）的乘法操作。输入门控制着新输入进入记忆单元<span class="markdown-equation" id="equation-15">$c$</span>的强度，遗忘门控制着记忆单元维持上一时刻值的强度，输出门控制着输出记忆单元的强度。三种门的计算方式类似，但有着完全不同的参数，它们各自以不同的方式控制着记忆单元<span class="markdown-equation" id="equation-15">$c$</span>，如图2所示：</p>
<p align="center">
<img align="center" src="image/lstm.png" width="65%"/><br/>
图2. 时刻<span class="markdown-equation" id="equation-0">$t$</span>的LSTM [7]
</p>
<p>LSTM通过给简单的循环神经网络增加记忆及控制门的方式，增强了其处理远距离依赖问题的能力。类似原理的改进还有Gated Recurrent Unit (GRU)[<a href="#参考文献">8</a>]，其设计更为简洁一些。<strong>这些改进虽然各有不同，但是它们的宏观描述却与简单的循环神经网络一样（如图2所示），即隐状态依据当前输入及前一时刻的隐状态来改变，不断地循环这一过程直至输入处理完毕：</strong></p>
<p><span class="markdown-equation" id="equation-30">$$ h_t=Recrurent(x_t,h_{t-1})$$</span></p>
<p>其中，<span class="markdown-equation" id="equation-31">$Recrurent$</span>可以表示简单的循环神经网络、GRU或LSTM。</p>
<h3>栈式双向LSTM（Stacked Bidirectional LSTM）</h3>
<p>对于正常顺序的循环神经网络，<span class="markdown-equation" id="equation-6">$h_t$</span>包含了<span class="markdown-equation" id="equation-0">$t$</span>时刻之前的输入信息，也就是上文信息。同样，为了得到下文信息，我们可以使用反方向（将输入逆序处理）的循环神经网络。结合构建深层循环神经网络的方法（深层神经网络往往能得到更抽象和高级的特征表示），我们可以通过构建更加强有力的基于LSTM的栈式双向循环神经网络[<a href="#参考文献">9</a>]，来对时序数据进行建模。  </p>
<p>如图3所示（以三层为例），奇数层LSTM正向，偶数层LSTM反向，高一层的LSTM使用低一层LSTM及之前所有层的信息作为输入，对最高层LSTM序列使用时间维度上的最大池化即可得到文本的定长向量表示（这一表示充分融合了文本的上下文信息，并且对文本进行了深层次抽象），最后我们将文本表示连接至softmax构建分类模型。</p>
<p align="center">
<img src="image/stacked_lstm.jpg" width="450"/><br/>
图3. 栈式双向LSTM用于文本分类
</p>
<h2>示例程序</h2>
<h3>数据集介绍</h3>
<p>我们以<a href="http://ai.stanford.edu/%7Eamaas/data/sentiment/">IMDB情感分析数据集</a>为例进行介绍。IMDB数据集的训练集和测试集分别包含25000个已标注过的电影评论。其中，负面评论的得分小于等于4，正面评论的得分大于等于7，满分10分。
</p><div class="highlight"><pre><span></span>aclImdb
|- test
   |-- neg
   |-- pos
|- train
   |-- neg
   |-- pos
</pre></div>
Paddle在<code>dataset/imdb.py</code>中提实现了imdb数据集的自动下载和读取，并提供了读取字典、训练数据、测试数据等API。
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">paddle.v2</span> <span class="kn">as</span> <span class="nn">paddle</span>
</pre></div>
<h2>配置模型</h2>
<p>在该示例中，我们实现了两种文本分类算法，分别基于<a href="https://github.com/PaddlePaddle/book/tree/develop/05.recommender_system">推荐系统</a>一节介绍过的文本卷积神经网络，以及<a href="#栈式双向LSTM（Stacked Bidirectional LSTM）">栈式双向LSTM</a>。</p>
<h3>文本卷积神经网络</h3>
<p></p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convolution_net</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span>
                    <span class="n">class_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">emb_dim</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
                    <span class="n">hid_dim</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
                    <span class="n">is_predict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">"word"</span><span class="p">,</span>
                             <span class="n">paddle</span><span class="o">.</span><span class="n">data_type</span><span class="o">.</span><span class="n">integer_value_sequence</span><span class="p">(</span><span class="n">input_dim</span><span class="p">))</span>
    <span class="n">emb</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">)</span>
    <span class="n">conv_3</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">networks</span><span class="o">.</span><span class="n">sequence_conv_pool</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">emb</span><span class="p">,</span> <span class="n">context_len</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span><span class="n">hid_dim</span><span class="p">)</span>
    <span class="n">conv_4</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">networks</span><span class="o">.</span><span class="n">sequence_conv_pool</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">emb</span><span class="p">,</span> <span class="n">context_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span><span class="n">hid_dim</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="p">[</span><span class="n">conv_3</span><span class="p">,</span> <span class="n">conv_4</span><span class="p">],</span>
                             <span class="n">size</span><span class="o">=</span><span class="n">class_dim</span><span class="p">,</span>
                             <span class="n">act</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">Softmax</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_predict</span><span class="p">:</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">"label"</span><span class="p">,</span> <span class="n">paddle</span><span class="o">.</span><span class="n">data_type</span><span class="o">.</span><span class="n">integer_value</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">classification_cost</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
网络的输入<code>input_dim</code>表示的是词典的大小，<code>class_dim</code>表示类别数。这里，我们使用<a href="https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/trainer_config_helpers/networks.py"><code>sequence_conv_pool</code></a> API实现了卷积和池化操作。
<h3>栈式双向LSTM</h3>
<p></p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">stacked_lstm_net</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span>
                     <span class="n">class_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">emb_dim</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
                     <span class="n">hid_dim</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                     <span class="n">stacked_num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                     <span class="n">is_predict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A Wrapper for sentiment classification task.</span>
<span class="sd">    This network uses bi-directional recurrent network,</span>
<span class="sd">    consisting three LSTM layers. This configure is referred to</span>
<span class="sd">    the paper as following url, but use fewer layrs.</span>
<span class="sd">        http://www.aclweb.org/anthology/P15-1109</span>

<span class="sd">    input_dim: here is word dictionary dimension.</span>
<span class="sd">    class_dim: number of categories.</span>
<span class="sd">    emb_dim: dimension of word embedding.</span>
<span class="sd">    hid_dim: dimension of hidden layer.</span>
<span class="sd">    stacked_num: number of stacked lstm-hidden layer.</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="n">stacked_num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">fc_para_attr</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">lstm_para_attr</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">initial_std</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">para_attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">fc_para_attr</span><span class="p">,</span> <span class="n">lstm_para_attr</span><span class="p">]</span>
    <span class="n">bias_attr</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="n">initial_std</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">l2_rate</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">relu</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">Relu</span><span class="p">()</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">Linear</span><span class="p">()</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">"word"</span><span class="p">,</span>
                             <span class="n">paddle</span><span class="o">.</span><span class="n">data_type</span><span class="o">.</span><span class="n">integer_value_sequence</span><span class="p">(</span><span class="n">input_dim</span><span class="p">))</span>
    <span class="n">emb</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">)</span>

    <span class="n">fc1</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">emb</span><span class="p">,</span>
                          <span class="n">size</span><span class="o">=</span><span class="n">hid_dim</span><span class="p">,</span>
                          <span class="n">act</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
                          <span class="n">bias_attr</span><span class="o">=</span><span class="n">bias_attr</span><span class="p">)</span>
    <span class="n">lstm1</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">lstmemory</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">fc1</span><span class="p">,</span> <span class="n">act</span><span class="o">=</span><span class="n">relu</span><span class="p">,</span> <span class="n">bias_attr</span><span class="o">=</span><span class="n">bias_attr</span><span class="p">)</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fc1</span><span class="p">,</span> <span class="n">lstm1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stacked_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                             <span class="n">size</span><span class="o">=</span><span class="n">hid_dim</span><span class="p">,</span>
                             <span class="n">act</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
                             <span class="n">param_attr</span><span class="o">=</span><span class="n">para_attr</span><span class="p">,</span>
                             <span class="n">bias_attr</span><span class="o">=</span><span class="n">bias_attr</span><span class="p">)</span>
        <span class="n">lstm</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">lstmemory</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">fc</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">act</span><span class="o">=</span><span class="n">relu</span><span class="p">,</span>
            <span class="n">bias_attr</span><span class="o">=</span><span class="n">bias_attr</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fc</span><span class="p">,</span> <span class="n">lstm</span><span class="p">]</span>

    <span class="n">fc_last</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pooling_type</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">pooling</span><span class="o">.</span><span class="n">Max</span><span class="p">())</span>
    <span class="n">lstm_last</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pooling_type</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">pooling</span><span class="o">.</span><span class="n">Max</span><span class="p">())</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="p">[</span><span class="n">fc_last</span><span class="p">,</span> <span class="n">lstm_last</span><span class="p">],</span>
                             <span class="n">size</span><span class="o">=</span><span class="n">class_dim</span><span class="p">,</span>
                             <span class="n">act</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(),</span>
                             <span class="n">bias_attr</span><span class="o">=</span><span class="n">bias_attr</span><span class="p">,</span>
                             <span class="n">param_attr</span><span class="o">=</span><span class="n">para_attr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_predict</span><span class="p">:</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">"label"</span><span class="p">,</span> <span class="n">paddle</span><span class="o">.</span><span class="n">data_type</span><span class="o">.</span><span class="n">integer_value</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">classification_cost</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
网络的输入<code>stacked_num</code>表示的是LSTM的层数，需要是奇数，确保最高层LSTM正向。Paddle里面是通过一个fc和一个lstmemory来实现基于LSTM的循环神经网络。
<h2>训练模型</h2>
<p></p><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="c1"># init</span>
    <span class="n">paddle</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">use_gpu</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
启动paddle程序，use_gpu=False表示用CPU训练，如果系统支持GPU也可以修改成True使用GPU训练。
<h3>训练数据</h3>
<p>使用Paddle提供的数据集<code>dataset.imdb</code>中的API来读取训练数据。
</p><div class="highlight"><pre><span></span>    <span class="k">print</span> <span class="s1">'load dictionary...'</span>
    <span class="n">word_dict</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">imdb</span><span class="o">.</span><span class="n">word_dict</span><span class="p">()</span>
    <span class="n">dict_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_dict</span><span class="p">)</span>
    <span class="n">class_dim</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
加载数据字典，这里通过<code>word_dict()</code>API可以直接构造字典。<code>class_dim</code>是指样本类别数，该示例中样本只有正负两类。
<div class="highlight"><pre><span></span>    <span class="n">train_reader</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span>
        <span class="n">paddle</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">paddle</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">imdb</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">word_dict</span><span class="p">),</span> <span class="n">buf_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">test_reader</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">paddle</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">imdb</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">word_dict</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
这里，<code>dataset.imdb.train()</code>和<code>dataset.imdb.test()</code>分别是<code>dataset.imdb</code>中的训练数据和测试数据API。<code>train_reader</code>在训练时使用，意义是将读取的训练数据进行shuffle后，组成一个batch数据。同理，<code>test_reader</code>是在测试的时候使用，将读取的测试数据组成一个batch。
<div class="highlight"><pre><span></span>    <span class="n">feeding</span><span class="o">=</span><span class="p">{</span><span class="s1">'word'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'label'</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
<code>feeding</code>用来指定<code>train_reader</code>和<code>test_reader</code>返回的数据与模型配置中data_layer的对应关系。这里表示reader返回的第0列数据对应<code>word</code>层，第1列数据对应<code>label</code>层。
<h3>构造模型</h3>
<p></p><div class="highlight"><pre><span></span>    <span class="c1"># Please choose the way to build the network</span>
    <span class="c1"># by uncommenting the corresponding line.</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">convolution_net</span><span class="p">(</span><span class="n">dict_dim</span><span class="p">,</span> <span class="n">class_dim</span><span class="o">=</span><span class="n">class_dim</span><span class="p">)</span>
    <span class="c1"># cost = stacked_lstm_net(dict_dim, class_dim=class_dim, stacked_num=3)</span>
</pre></div>
该示例中默认使用<code>convolution_net</code>网络，如果使用<code>stacked_lstm_net</code>网络，注释相应的行即可。其中cost是网络的优化目标，同时cost包含了整个网络的拓扑信息。
<h3>网络参数</h3>
<p></p><div class="highlight"><pre><span></span>    <span class="c1"># create parameters</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
</pre></div>
根据网络的拓扑构造网络参数。这里parameters是整个网络的参数集。
<h3>优化算法</h3>
<p></p><div class="highlight"><pre><span></span>    <span class="c1"># create optimizer</span>
    <span class="n">adam_optimizer</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span>
        <span class="n">regularization</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">L2Regularization</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="mf">8e-4</span><span class="p">),</span>
        <span class="n">model_average</span><span class="o">=</span><span class="n">paddle</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">ModelAverage</span><span class="p">(</span><span class="n">average_window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
</pre></div>
Paddle中提供了一系列优化算法的API，这里使用Adam优化算法。
<h3>训练</h3>
<p>可以通过<code>paddle.trainer.SGD</code>构造一个sgd trainer，并调用<code>trainer.train</code>来训练模型。另外，通过给train函数传递一个<code>event_handler</code>来获取每个batch和每个pass结束的状态。
</p><div class="highlight"><pre><span></span>    <span class="c1"># End batch and end pass event handler</span>
    <span class="k">def</span> <span class="nf">event_handler</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">paddle</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">EndIteration</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">batch_id</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Pass </span><span class="si">%d</span><span class="s2">, Batch </span><span class="si">%d</span><span class="s2">, Cost </span><span class="si">%f</span><span class="s2">, </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">pass_id</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">batch_id</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">paddle</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">EndPass</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'./params_pass_</span><span class="si">%d</span><span class="s1">.tar'</span> <span class="o">%</span> <span class="n">event</span><span class="o">.</span><span class="n">pass_id</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">trainer</span><span class="o">.</span><span class="n">save_parameter_to_tar</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">reader</span><span class="o">=</span><span class="n">test_reader</span><span class="p">,</span> <span class="n">feeding</span><span class="o">=</span><span class="n">feeding</span><span class="p">)</span>
            <span class="k">print</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Test with Pass </span><span class="si">%d</span><span class="s2">, </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">pass_id</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
</pre></div>
比如，构造如下一个<code>event_handler</code>可以在每100个batch结束后输出cost和error；在每个pass结束后调用<code>trainer.test</code>计算一遍测试集并获得当前模型在测试集上的error。
<div class="highlight"><pre><span></span>    <span class="kn">from</span> <span class="nn">paddle.v2.plot</span> <span class="kn">import</span> <span class="n">Ploter</span>

    <span class="n">train_title</span> <span class="o">=</span> <span class="s2">"Train cost"</span>
    <span class="n">cost_ploter</span> <span class="o">=</span> <span class="n">Ploter</span><span class="p">(</span><span class="n">train_title</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">event_handler_plot</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">step</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">paddle</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">EndIteration</span><span class="p">):</span>
            <span class="n">cost_ploter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_title</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">cost_ploter</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
或者构造一个<code>event_handler_plot</code>画出cost曲线。
<div class="highlight"><pre><span></span>    <span class="c1"># create trainer</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">trainer</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span>
                                 <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                                 <span class="n">update_equation</span><span class="o">=</span><span class="n">adam_optimizer</span><span class="p">)</span>

    <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
        <span class="n">reader</span><span class="o">=</span><span class="n">train_reader</span><span class="p">,</span>
        <span class="n">event_handler</span><span class="o">=</span><span class="n">event_handler</span><span class="p">,</span>
        <span class="n">feeding</span><span class="o">=</span><span class="n">feeding</span><span class="p">,</span>
        <span class="n">num_passes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
程序运行之后的输出如下。
<div class="highlight"><pre><span></span>Pass 0, Batch 0, Cost 0.693721, {'classification_error_evaluator': 0.5546875}
...................................................................................................
Pass 0, Batch 100, Cost 0.294321, {'classification_error_evaluator': 0.1015625}
...............................................................................................
Test with Pass 0, {'classification_error_evaluator': 0.11432000249624252}
</pre></div>
<h2>应用模型</h2>
<p>可以使用训练好的模型对电影评论进行分类，下面程序展示了如何使用<code>paddle.infer</code>接口进行推断。
</p><div class="highlight"><pre><span></span>    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    <span class="c1"># Movie Reviews, from imdb test</span>
    <span class="n">reviews</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'Read the book, forget the movie!'</span><span class="p">,</span>
        <span class="s1">'This is a great movie.'</span>
    <span class="p">]</span>
    <span class="n">reviews</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">reviews</span><span class="p">]</span>

    <span class="n">UNK</span> <span class="o">=</span> <span class="n">word_dict</span><span class="p">[</span><span class="s1">'&lt;unk&gt;'</span><span class="p">]</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">reviews</span><span class="p">:</span>
        <span class="nb">input</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">word_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">UNK</span><span class="p">)</span> <span class="k">for</span> <span class="n">words</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]])</span>

    <span class="c1"># 0 stands for positive sample, 1 stands for negative sample</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">'pos'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">'neg'</span><span class="p">}</span>
    <span class="c1"># Use the network used by trainer</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">convolution_net</span><span class="p">(</span><span class="n">dict_dim</span><span class="p">,</span> <span class="n">class_dim</span><span class="o">=</span><span class="n">class_dim</span><span class="p">,</span> <span class="n">is_predict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># out = stacked_lstm_net(dict_dim, class_dim=class_dim, stacked_num=3, is_predict=True)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">paddle</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">output_layer</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>

    <span class="n">labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labs</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">idx</span><span class="p">,</span> <span class="s2">"predicting probability is"</span><span class="p">,</span> <span class="n">probs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="s2">"label is"</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
<h2>总结</h2>
<p>本章我们以情感分析为例，介绍了使用深度学习的方法进行端对端的短文本分类，并且使用PaddlePaddle完成了全部相关实验。同时，我们简要介绍了两种文本处理模型：卷积神经网络和循环神经网络。在后续的章节中我们会看到这两种基本的深度学习模型在其它任务上的应用。</p>
<h2>参考文献</h2>
<ol>
<li>Kim Y. <a href="http://arxiv.org/pdf/1408.5882">Convolutional neural networks for sentence classification</a>[J]. arXiv preprint arXiv:1408.5882, 2014.</li>
<li>Kalchbrenner N, Grefenstette E, Blunsom P. <a href="http://arxiv.org/pdf/1404.2188.pdf?utm_medium=App.net&amp;utm_source=PourOver">A convolutional neural network for modelling sentences</a>[J]. arXiv preprint arXiv:1404.2188, 2014.</li>
<li>Yann N. Dauphin, et al. <a href="https://arxiv.org/pdf/1612.08083v1.pdf">Language Modeling with Gated Convolutional Networks</a>[J] arXiv preprint arXiv:1612.08083, 2016.</li>
<li>Siegelmann H T, Sontag E D. <a href="http://research.cs.queensu.ca/home/akl/cisc879/papers/SELECTED_PAPERS_FROM_VARIOUS_SOURCES/05070215382317071.pdf">On the computational power of neural nets</a>[C]//Proceedings of the fifth annual workshop on Computational learning theory. ACM, 1992: 440-449.</li>
<li>Hochreiter S, Schmidhuber J. <a href="http://web.eecs.utk.edu/~itamar/courses/ECE-692/Bobby_paper1.pdf">Long short-term memory</a>[J]. Neural computation, 1997, 9(8): 1735-1780.</li>
<li>Bengio Y, Simard P, Frasconi P. <a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf">Learning long-term dependencies with gradient descent is difficult</a>[J]. IEEE transactions on neural networks, 1994, 5(2): 157-166.</li>
<li>Graves A. <a href="http://arxiv.org/pdf/1308.0850">Generating sequences with recurrent neural networks</a>[J]. arXiv preprint arXiv:1308.0850, 2013.</li>
<li>Cho K, Van Merriënboer B, Gulcehre C, et al. <a href="http://arxiv.org/pdf/1406.1078">Learning phrase representations using RNN encoder-decoder for statistical machine translation</a>[J]. arXiv preprint arXiv:1406.1078, 2014.</li>
<li>Zhou J, Xu W. <a href="http://www.aclweb.org/anthology/P/P15/P15-1109.pdf">End-to-end learning of semantic role labeling using recurrent neural networks</a>[C]//Proceedings of the Annual Meeting of the Association for Computational Linguistics. 2015.</li>
</ol>
<p><br/>
<a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license"><img alt="知识共享许可协议" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" style="border-width:0"/></a><br/><span href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type" xmlns:dct="http://purl.org/dc/terms/">本教程</span> 由 <a href="http://book.paddlepaddle.org" property="cc:attributionName" rel="cc:attributionURL" xmlns:cc="http://creativecommons.org/ns#">PaddlePaddle</a> 创作，采用 <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">知识共享 署名-相同方式共享 4.0 国际 许可协议</a>进行许可。</p>
{% endverbatim %}